{"name":"Libflat","tagline":"Library for fast serialization of C structures","body":"##Introduction\r\nLibflat is a library for fast serialization of C structures. Its main goal is speed (and of course correctness). Most of the time when you serialize your data the speed doesn't really matter (in contrast to other factors like simplicity, good coverage etc.). But there are cases when the speed is crucial, i.e. you're working with some big data sets and you need to serialize/deserialize them often (you might have some H/W device that produces a mass of data for further processing and you want to read in and analyze this data on another machine).<br>\r\n\r\nIn standard approach for serialization you pick up or design some protocol (e.g. based on JSON) and write the logic to save your structures. On the other side of the mirror you read in the packets, figure out what they represent and combine them to recreate your beloved data. This is fine. This works well. Unfortunately sometimes this works rather slow (rarely though and most of the time you can get away with it). Libflat is about to make this process as fast as possible by all cost.<br>\r\n\r\nGood example for using Libflat is Android build system (still based on Makefile build system as of Feb. 2016). Androd build system is monolithic which makes it extremely parallelizable.<br>\r\nThe main obstacle though (especially when you need to do lots of partial builds) is that you need to read all the makefiles up front (and there is lots of them). Trying it with hot caches gives the following (tests for android-6.0.0_r5)<br>\r\n```\r\n$ source build/envsetup.sh\r\n$ lunch aosp_arm64-eng\r\n$ time make\r\n============================================\r\nPLATFORM_VERSION_CODENAME=REL\r\nPLATFORM_VERSION=6.0\r\nTARGET_PRODUCT=aosp_arm64\r\nTARGET_BUILD_VARIANT=eng\r\nTARGET_BUILD_TYPE=release\r\nTARGET_BUILD_APPS=\r\nTARGET_ARCH=arm64\r\nTARGET_ARCH_VARIANT=armv8-a\r\nTARGET_CPU_VARIANT=generic\r\nTARGET_2ND_ARCH=arm\r\nTARGET_2ND_ARCH_VARIANT=armv7-a-neon\r\nTARGET_2ND_CPU_VARIANT=cortex-a15\r\nHOST_ARCH=x86_64\r\nHOST_OS=linux\r\nHOST_OS_EXTRA=Linux-3.13.0-58-generic-x86_64-with-Ubuntu-14.04-trusty\r\nHOST_BUILD_TYPE=release\r\nBUILD_ID=MRA58K\r\nOUT_DIR=out\r\n============================================\r\nincluding ./abi/cpp/Android.mk ...\r\nincluding ./art/Android.mk ...\r\nincluding ./bionic/Android.mk ...\r\n...\r\nincluding ./system/security/softkeymaster/Android.mk ...\r\nincluding ./system/vold/Android.mk ...\r\nincluding ./tools/external/fat32lib/Android.mk ...\r\n```\r\nSummary:<br>\r\n```\r\nreal    0m41.977s\r\nuser    0m32.590s\r\nsys     0m9.654s\r\n```\r\nNot so bad, especially when you have lots of RAM (so the only job that needs to be done is to parse all the Makefiles in memory using one thread). But what if we can omit the parsing phase at all and read in the whole memory content ready for going (or almost ready)?<br>\r\n\r\n##How Libflat works\r\n\r\nLibflat works by making copy of the process memory for indicated variables and structures. It doesn't matter whether original storage is automatic, static or allocated. The result is always stored on the heap (and kept on the heap after deserialization). Memory image is flat, i.e. whole copied memory image has continuous addresses. Pointers to original memory locations are properly resolved in the flattened image. Having whole memory serialized into one continuous memory block makes deserialization very fast (it is just a matter of reading entire block from disk to memory). Pointer resolution phase is needed after image is read in but this has linear complexity with number of pointers.<br>\r\n\r\nSimplest possible case of serialization can be made for automatic int variable as follows:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    int automatic = 0xDABBAD00;\r\n\r\n    FOR_ROOT_POINTER(&automatic,\r\n        FLATTEN_TYPE(int, &automatic);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/1-in\r\n# Flattening done. Summary:\r\n  Memory size: 4 bytes\r\n  Linked 0 pointers\r\n  Written 44 bytes\r\n```\r\nOn the other side reading the stored value can be now done by:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    int* now_allocated = ROOT_POINTER_NEXT(int*);\r\n    printf(\"%08X\\n\", *now_allocated);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/1-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000036s\r\n  Fixing memory time: 0.000000s\r\n  Total time: 0.000063s\r\n  Total bytes read: 44\r\nDABBAD00\r\n```\r\nSimilar procedure can be done with arrays and strings as in the below examples:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    int i;\r\n    const char* s = \"Fibonacci would not calculate this as fast\";\r\n    long fib[40] = { 0, 1 };\r\n    for (i = 2; i < 40; ++i)\r\n        fib[i] = fib[i - 1] + fib[i - 2];\r\n\r\n    FOR_ROOT_POINTER(fib,\r\n        FLATTEN_TYPE_ARRAY(long, fib, 40);\r\n    );\r\n\r\n    FOR_ROOT_POINTER(s,\r\n        FLATTEN_STRING(s);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/2-in\r\n# Flattening done. Summary:\r\n  Memory size: 363 bytes\r\n  Linked 0 pointers\r\n  Written 411 bytes\r\n```\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    long* fib = ROOT_POINTER_SEQ(long*, 0);\r\n    const char* s = ROOT_POINTER_SEQ(const char*, 1);\r\n\r\n    int i;\r\n    for (i = 0; i < 40; ++i)\r\n        printf(\"%ld \", fib[i]);\r\n    printf(\"\\n\");\r\n    printf(\"%s\\n\", s);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/2-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000055s\r\n  Fixing memory time: 0.000000s\r\n  Total time: 0.000100s\r\n  Total bytes read: 411\r\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 \r\nFibonacci would not calculate this as fast\r\n```\r\nThis brings the notion of the so called root pointer. When you read the contents of memory you will have a block of data to your disposal. But how to access it? You need some pointer to any part of this memory (assuming you can interpret the memory from this point and link to other parts). This is what the root pointer is for. It is just a pointer to some part of unflatten memory. This has its own storage and is not part of the memory image (but of course it is part of the image file).<br>\r\nLet's back to our first example. <br>\r\n```c\r\nint automatic = 0xDABBAD00;\r\n\r\nFOR_ROOT_POINTER(&automatic,\r\n    FLATTEN_TYPE(int, &automatic);\r\n);\r\n```\r\nWe simply told our flattener engine that we want to access the memory through the address of the `automatic` variable (i.e. we will hold it reference). Check out that flattened memory size is 4 c-bytes (which happens to be the sizeof(int) on my example making machine). But it doesn't need to be this way. We can modify the first example slightly and specify the root pointer address through some other pointer variable:\r\n```c\r\nint automatic = 0xDABBAD00;\r\nint* pi = &automatic;\r\n\r\nFOR_ROOT_POINTER(pi,\r\n    FLATTEN_TYPE(int, &automatic);\r\n);\r\n```\r\nAfter image read we just assign this value to our own defined variable as below:<br>\r\n```c\r\nint* now_allocated = ROOT_POINTER_NEXT(int*);\r\n```\r\nYou might have several root pointers to several parts of unflatten memory. To access them you simply call `ROOT_POINTER_NEXT` with proper type sequentially to receive one root pointer after another (you will get them in the order you did issue `FOR_ROOT_POINTER` macro in the first place). You can also retrieve root pointers as below:<br>\r\n```c\r\nconst char* s = ROOT_POINTER_SEQ(const char*, 1);\r\n```\r\nThis will read the second (with index 1) root pointer stored while creating memory image.<br>\r\n\r\nAs you might have noticed in order to flatten some type you will need a pointer to it. But what about pointers (or pointers to pointers etc.)? There is no difference as long as you have a pointer to it (or pointer to pointer to it). Huh?<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    double magic_number = 3.14159265359;\r\n    double* pointer_to_it = &magic_number;\r\n    double** pointer_to_pointer_to_it = &pointer_to_it;\r\n    double*** ehhh = &pointer_to_pointer_to_it;\r\n\r\n    FOR_ROOT_POINTER(ehhh,\r\n        FLATTEN_TYPE(double**, &pointer_to_pointer_to_it);\r\n        FOR_POINTER(double**,p, &pointer_to_pointer_to_it,\r\n            FLATTEN_TYPE(double*, p);\r\n            FOR_POINTER(double*, q, p,\r\n                FLATTEN_TYPE(double, q);\r\n            );\r\n        );\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/3-in\r\n# Flattening done. Summary:\r\n  Memory size: 24 bytes\r\n  Linked 2 pointers\r\n  Written 80 bytes\r\n```\r\nYou have just written three values into memory (two pointers and one double value). How so?<br>\r\n\r\nThe line:<br>\r\n```c\r\nFLATTEN_TYPE(double**, &pointer_to_pointer_to_it);\r\n```\r\nwrites the value pointed to by `&pointer_to_pointer_to_it` which is of type double** (this is the actual value stored in the `pointer_to_pointer_to_it` pointer). We did exactly the same in the first example:<br>\r\n```c\r\nFLATTEN_TYPE(int, &automatic);\r\n```\r\nWe wrote the value pointed to by `&automatic` which was of type int.<br>\r\n\r\nNext line:<br>\r\n```c\r\nFOR_POINTER(double**, p, &pointer_to_pointer_to_it,...);\r\n```\r\ntakes the actual value pointed to by `&pointer_to_pointer_to_it` and stores it in newly created variable `p` of appropriate type (double**). This variable must be pointer hence the macro name. New variable `p` (you can actually give it any accessible name) can be used in the block of code that follows (`...` macro arguments).<br>\r\n\r\nThe following code we does the same trick, i.e. writes the value pointed by `p` (of type double*):<br>\r\n```c\r\nFLATTEN_TYPE(double*, p);\r\n```\r\nFinally we create another variable `q` that acquires the value pointed by `p` (which finally points to the magic double value) and writes the double number to the memory image:<br>\r\n```c\r\nFOR_POINTER(double*, q, p,\r\n    FLATTEN_TYPE(double, q);\r\n);\r\n```\r\nChecking the stored value confirms our words:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    double*** ehhh = ROOT_POINTER_SEQ(double***, 0);\r\n    printf(\"The magic answer to the ultimate question of life?: %f\\n\", ***ehhh);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/3-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000058s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000105s\r\n  Total bytes read: 80\r\nThe magic answer to the ultimate question of life?: 3.141593\r\n```\r\n<LINK>In the write output you can now see the line that says:<br>\r\n```\r\nLinked 2 pointers\r\n```\r\nThe memory image contained two pointers as we just explained. But after reading them in in the second process (which could actually happened on different computer on diffrenent continent) the pointer values would not probably have any proper meaning in the context of new process address space. That's why we need to fix them.<br>\r\n\r\nConsider the following block of code:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    static char carr[] = \"You don't need to be great to start, \"\r\n            \"but you need to start to be great\";\r\n\r\n    const char* start = carr;\r\n    const char* middle = carr + 41;\r\n\r\n    FOR_ROOT_POINTER(start,\r\n        FLATTEN_TYPE(const char*, &start);\r\n        FOR_POINTER(const char*, s, &start,\r\n            FLATTEN_STRING(s);\r\n        );\r\n    );\r\n\r\n    FOR_ROOT_POINTER(middle,\r\n        FLATTEN_TYPE(const char*, &middle);\r\n        FOR_POINTER(const char*, s, &middle,\r\n            FLATTEN_STRING(s);\r\n        );\r\n    );\r\n\r\n    printf(\"&carr[0]: %p\\n\", &carr[0]);\r\n    printf(\"&start: %p -> %p\\n\", &start, start);\r\n    printf(\"&middle: %p -> %p\\n\", &middle, middle);\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\nAnd the result of running it:<br>\r\n```\r\n$ examples/4-in\r\n&carr[0]: 0x6020c0\r\n&start: 0x7fff9da3a8c0 -> 0x6020c0\r\n&middle: 0x7fff9da3a8c8 -> 0x6020e9\r\n# Flattening done. Summary:\r\n  Memory size: 87 bytes\r\n  Linked 2 pointers\r\n  Written 151 bytes\r\n```\r\nThe original memory looks as follows:<br>\r\n\r\nSomewhere in the static memory area:<br>\r\n```\r\n0x6020c0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0]\r\n                                 ^\r\n                                 0x6020e9\r\n```\r\nSomewhere on the stack:<br>\r\n```\r\n0x7fff9da3a8c0: [0x6020c0|0x6020e9]\r\n```\r\nLibflat will arrange memory image in ascending order of original addresses:<br>\r\n```\r\n[Y|o|u|...|g|r|e|a|t|0|0x6020c0|0x6020e9]\r\n```\r\nand replace original pointer values with its position independent counterparts (independent from the starting address of the memory image in the process address space):<br>\r\n```\r\n[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029]\r\n ^                     ^\r\n 0x000000              0x000029\r\n```\r\nIt also needs to store two additional values, i.e. at which offset in the flattened memory area actual pointers appears (as we need to find them later):<br>\r\n```\r\n[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f]\r\n                                             ^        ^\r\n                                             0x47     0x4f\r\n```\r\nFinally it also stores two root pointers (start and middle pointer values) as the offsets in the flattened memory image for later retrieval:<br>\r\n```\r\n[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f] [0x47,0x4f]\r\n                                                                             ^    ^\r\n                                                                             start offset\r\n                                                                                  ^\r\n                                                                                  middle offset\r\n```\r\nIn this example we have only two pointers and both of them are root pointers therefore stored values are duplicated. In real life scenarios we will probably have much more standard pointers and very few root pointers (as all must be manually setup by programmer).<br>\r\n\r\nDuring unflattening stage (as in the below example) several things happen.<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    const char* start = ROOT_POINTER_SEQ(const char*, 0);\r\n    const char* middle = ROOT_POINTER_SEQ(const char*, 1);\r\n\r\n    printf(\"&start: %p -> %p\\n\", &start, start);\r\n    printf(\"&middle: %p -> %p\\n\", &middle, middle);\r\n    const void* ptr1 = start + strlen(start) + 1;\r\n    printf(\"*(%p) => %p\\n\", ptr1, *(void**) ptr1);\r\n    const void* ptr2 = start + strlen(start) + 1 + sizeof(const char*);\r\n    printf(\"*(%p) => %p\\n\", ptr2, *(void**) ptr2);\r\n    printf(\"%s\\n\", start);\r\n    printf(\"Remember: %s\\n\", middle);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/4-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000037s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000068s\r\n  Total bytes read: 151\r\n&start: 0x7ffe7454eae0 -> 0x8de2a0\r\n&middle: 0x7ffe7454eae8 -> 0x8de2c9\r\n*(0x8de2e7) => 0x8de2a0\r\n*(0x8de2ef) => 0x8de2c9\r\nYou don't need to be great to start, but you need to start to be great\r\nRemember: you need to start to be great\r\n```\r\nNew memory area is created in the allocated storage area (the heap) and memory image is read in:<br>\r\n```\r\n0x8de2a0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f] [0x47,0x4f]\r\n                                 ^\r\n                                 0x8de2c9\r\n```\r\nNow we read two pointer offsets (0x47 and 0x4f) and fix two pointers at these offsets by adding the initial address of the allocated memory area to the position independent pointer value:<br>\r\n```\r\n0x8de2a0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x8de2a0|0x8de2c9] [0x47,0x4f] [0x47,0x4f]\r\n                                 ^                     ^        ^         ^ pointer offset array\r\n                                 0x8de2c9              0x47     0x4f                   ^\r\n                                                       ^        ^                      root pointer offset array\r\n                                                       0x8de2e7 0x8de2ef\r\n```\r\nNow the first pointer points at the beginning of the string and second points in the middle. This process is called linking and this is what the line `Linked 2 pointers` was talking about.<br>\r\n\r\nFinally we read two root pointers at offset location 0x47 and 0x4f which happens to be the same values as the only two pointers, create their storage and set the translated values:<br>\r\n```\r\n&start: 0x7ffe7454eae0 -> 0x8de2a0\r\n&middle: 0x7ffe7454eae8 -> 0x8de2c9\r\n```\r\nTo finally confirm the example we will move start pointer (and the second pointer) by the length of the string and read the value stored at the resulting location:<br>\r\n```c\r\nconst void* ptr1 = start + strlen(start) + 1;\r\nprintf(\"*(%p) => %p\\n\", ptr1, *(void**)ptr1);\r\nconst void* ptr2 = start + strlen(start) + 1 + sizeof(const char*);\r\nprintf(\"*(%p) => %p\\n\", ptr2, *(void**)ptr2);\r\n```\r\n```\r\n*(0x8de2e7) => 0x8de2a0\r\n*(0x8de2ef) => 0x8de2c9\r\n```\r\nThere is actually more you can do with pointers. For instance you can manage arrays of pointers in similar fashion:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    const char* argv[] = { \"Program name\", \"Argument 0\", \"Argument 1\",\r\n            \"Argument 2\", \"Argument 3\", 0 };\r\n\r\n    FOR_ROOT_POINTER(argv,\r\n        FOREACH_POINTER(const char*, arg, argv,\r\n                ptrarrmemlen((const void * const*)argv),\r\n            FLATTEN_TYPE(const char*, arg);\r\n            FLATTEN_STRING(arg);\r\n        );\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/5-in\r\n# Flattening done. Summary:\r\n  Memory size: 105 bytes\r\n  Linked 5 pointers\r\n  Written 185 bytes\r\n```\r\nHere, for each pointer in the array `argv` we create temporary variable `arg` of type `const char*` which we can use in the subsequent block of code. We must specify the size of the array. We might know it in advance or we can compute it in real time. In case of arrays terminated with pointer 0 (NULL pointer) there is function `ptrarrmemlen` available for this purpose. It simply iterates through entire pointer array and counts the pointers until it reaches the pointer 0 (and counts it as well). Similar function is used internally by the `FLATTEN_STRING` macro, i.e. `strmemlen` function which returns the length of string including NULL terminating 0 value.<br>\r\n\r\nIn the code body we first flatten the pointer itself and then we flatten the string pointed to by it.<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    const char** argv = ROOT_POINTER_NEXT(const char**);\r\n    while (*argv) {\r\n        printf(\"%s\\n\", *argv);\r\n        argv++;\r\n    }\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/5-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000057s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000104s\r\n  Total bytes read: 185\r\nProgram name\r\nArgument 0\r\nArgument 1\r\nArgument 2\r\nArgument 3\r\n```\r\nWe finally came to the last (and most interesting) part where all the fun really begins, i.e. flattening C structures. Flattening C structure is as simple as:<br>\r\n```c\r\nFLATTEN_STRUCT(type, pointer);\r\n```\r\nHowever you have to provide recipe how to actually flatten structure internal fields. In the below example we want to flatten structure `figure` (which happens to be a square):<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nstruct point {\r\n    double x;\r\n    double y;\r\n};\r\n\r\nstruct edge {\r\n    struct point p[2];\r\n    struct edge* e;\r\n};\r\n\r\nstruct figure {\r\n    const char* name;\r\n    struct edge* e;\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(figure);\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    struct point sqv[4] = {{1.0, 1.0}, {1.0, -1.0}, {-1.0, -1.0}, {-1.0, 1.0}};\r\n    struct edge sqe[4] = {\r\n            { {sqv[0],sqv[1]}, &sqe[1] },\r\n            { {sqv[1],sqv[2]}, &sqe[2] },\r\n            { {sqv[2],sqv[3]}, &sqe[3] },\r\n            { {sqv[3],sqv[0]}, &sqe[0] }\r\n    };\r\n\r\n    struct figure square = { \"square\", sqe };\r\n\r\n    printf(\"sizeof(struct figure): %zu\\n\", sizeof(struct figure));\r\n\r\n    FOR_ROOT_POINTER(&square,\r\n        FLATTEN_STRUCT(figure, &square);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/6-in_a\r\nsizeof(struct figure): 16\r\n# Flattening done. Summary:\r\n  Memory size: 16 bytes\r\n  Linked 0 pointers\r\n  Written 56 bytes\r\n```\r\nAs we can see the structure has been actually flattened but quick glance reveals that not everything might have gone as expected. We have just written 16 bytes (the size of the structure) itself but no internal fields has been touched (and they will point to the vain after reading them out).<br>\r\n\r\nThe function providing the recipe how to flatten internal structure fields is called `FUNCTION_DEFINE_FLATTEN_STRUCT`. We should provide the type of the structure and the code responsible for writing structure content. Let's workout the example a little more and add the following functions:<br>\r\n```c\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(edge,\r\n    AGGREGATE_FLATTEN_STRUCT(edge, e);\r\n);\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(figure,\r\n    AGGREGATE_FLATTEN_STRING(name);\r\n    AGGREGATE_FLATTEN_STRUCT(edge, e);\r\n);\r\n```\r\n```\r\n$ examples/6-in_b\r\nsizeof(struct figure): 16\r\n# Flattening done. Summary:\r\n  Memory size: 183 bytes\r\n  Linked 6 pointers\r\n  Written 271 bytes\r\n```\r\nVoila! By adding several lines of code we managed to write down the whole figure properly resolving all pointers along the way.<br>\r\nSo far we have seen several functions for writing memory image, i.e.:<br>\r\n```c\r\nFLATTEN_STRING(pointer)\r\nFLATTEN_TYPE(type, pointer)\r\nFLATTEN_TYPE_ARRAY(type, pointer, size)\r\nFLATTEN_STRUCT(type, pointer)\r\n```\r\nThere is one more function we can use to save memory structures:<br>\r\n```c\r\nFLATTEN_STRUCT_ARRAY(type, pointer, size)\r\n```\r\nIt's actually a convenience function that takes the burden of serializing a structure array pointer by pointer off from the user. It is needed to bring the following definition when using it:<br>\r\n```c\r\nINLINE_FUNCTION_DEFINE_FLATTEN_STRUCT_ARRAY(type)\r\n```\r\nEach of these five functions has so called AGGREGATE counterparts, i.e.:<br>\r\n```c\r\nAGGREGATE_FLATTEN_STRING(field)\r\nAGGREGATE_FLATTEN_TYPE(type, field)\r\nAGGREGATE_FLATTEN_TYPE_ARRAY(type, field, size)\r\nAGGREGATE_FLATTEN_STRUCT(type, field)\r\nAGGREGATE_FLATTEN_STRUCT_ARRAY(type, field, size)\r\n```\r\nInstead of pointer to variable we use the corresponding field name from within the structure.<br>\r\n\r\nIf we want to use the field name itself for other purpose (i.e. length of the array for some other structure field) we have available macro:<br>\r\n```c\r\nATTR(field)\r\n```\r\nFinally to bring the structure flattening functions declarations across translation units we can use macro:<br>\r\n```c\r\nFUNCTION_DECLARE_FLATTEN_STRUCT(type)\r\n```\r\nPlease note that in the above example we didn't write function recipe for flattening the `struct point`. We also omitted field `p` from the `struct edge`. These values are part of internal structure storage (they are not pointers) therefore there's no need for recursive resolution of those fields (they will be flattened together with the original structure storage).<br>\r\n\r\nReading up the square structure from memory image is straightforward:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include <math.h>\r\n#include \"libflat.h\"\r\n\r\nstruct point {\r\n    double x;\r\n    double y;\r\n};\r\n\r\nstruct edge {\r\n    struct point p[2];\r\n    struct edge* e;\r\n};\r\n\r\nstruct figure {\r\n    const char* name;\r\n    struct edge* e;\r\n};\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    const struct figure* square = ROOT_POINTER_NEXT(const struct figure*);\r\n\r\n    struct edge* e = square->e;\r\n    double circumference = 0;\r\n    do {\r\n        circumference += sqrt(\r\n                pow(e->p[0].x - e->p[1].x, 2) + pow(e->p[0].y - e->p[1].y, 2));\r\n        e = e->e;\r\n    } while (e != square->e);\r\n\r\n    printf(\"%s circumference: %f\\n\", square->name, circumference);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/6-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000051s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000095s\r\n  Total bytes read: 271\r\nsquare circumference: 8.000000\r\n```\r\nIt would be also possible to flatten the entire structure with all links using mere pointer flattening functions but in that case we would need to implement the recursive structure member resolution by ourselves:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nstruct point {\r\n    double x;\r\n    double y;\r\n};\r\n\r\nstruct edge {\r\n    struct point p[2];\r\n    struct edge* e;\r\n};\r\n\r\nstruct figure {\r\n    const char* name;\r\n    struct edge* e;\r\n};\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    struct point sqv[4] = {{1.0, 1.0}, {1.0, -1.0}, {-1.0, -1.0}, {-1.0, 1.0}};\r\n    struct edge sqe[4] = {\r\n            { {sqv[0],sqv[1]}, &sqe[1] },\r\n            { {sqv[1],sqv[2]}, &sqe[2] },\r\n            { {sqv[2],sqv[3]}, &sqe[3] },\r\n            { {sqv[3],sqv[0]}, &sqe[0] }\r\n    };\r\n\r\n    struct figure square = { \"square\", sqe };\r\n\r\n    printf(\"sizeof(struct figure): %zu\\n\", sizeof(struct figure));\r\n\r\n    FOR_ROOT_POINTER(&square,\r\n        FOR_POINTER(const char*, n, &square.name,\r\n            FLATTEN_STRING(n);\r\n        );\r\n        FOR_POINTER(const char*, n, &square.e,\r\n            FLATTEN_TYPE(struct edge*,n);\r\n        );\r\n        struct edge* e = square.e;\r\n        do {\r\n            FOR_POINTER(struct edge*, pe, &e->e,\r\n                FLATTEN_TYPE_ARRAY(struct point,pe->p, 2);\r\n                FLATTEN_TYPE(struct edge*, pe);\r\n            );\r\n            e = e->e;\r\n        } while(e!=square.e);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/6-in_c\r\nsizeof(struct figure): 16\r\n# Flattening done. Summary:\r\n  Memory size: 183 bytes\r\n  Linked 6 pointers\r\n  Written 271 bytes\r\n```\r\nIn the final example we will try to pressure the library a little bit and notice how it responds to more demanding job. Let's modify the previous example and try to approximate a circle. To avoid stack overflow (in the previous example walking through the edges during flattening stage required one recursive call deeper per each edge) we will modify the structures slightly. `struct figure` will hold a table of all points and each point will hold a pointer to each other point in the polygon. We will build regular polygon with points around the circle circumference of radius 1. When number of points is 8 it would look something like below:<br>\r\n\r\n![Figure 1.](https://github.com/braton/libflat/blob/gh-pages/images/figure_1.png)\r\n\r\nWe will describe the flattening recipe for each structure as in the full example below:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <math.h>\r\n#include \"libflat.h\"\r\n\r\nstruct point {\r\n    double x;\r\n    double y;\r\n    unsigned n;\r\n    struct point** other;\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(point,\r\n    AGGREGATE_FLATTEN_TYPE_ARRAY(struct point*, other, ATTR(n));\r\n    FOREACH_POINTER(struct point*, p, ATTR(other), ATTR(n),\r\n            FLATTEN_STRUCT(point, p);\r\n    );\r\n);\r\n\r\nstruct figure {\r\n    const char* name;\r\n    unsigned n;\r\n    struct point* points;\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(figure,\r\n    AGGREGATE_FLATTEN_STRING(name);\r\n    AGGREGATE_FLATTEN_STRUCT_ARRAY(point,points,ATTR(n));\r\n);\r\n\r\nint main(int argc, char** argv) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    assert(argc > 1);\r\n    struct figure circle = { \"circle\" };\r\n    assert(sscanf(argv[1], \"%u\", &circle.n) == 1);\r\n    assert(circle.n > 1);\r\n    circle.points = calloc(circle.n, sizeof(struct point));\r\n    assert(circle.points);\r\n    double radius = 1.0, angle = 2 * M_PI / circle.n;\r\n\r\n#define MAKE_POINT(p, i, N)   \\\r\n    p.x = cos(angle*(radius*(i)));  \\\r\n    p.y = sin(angle*(radius*(i)));  \\\r\n    p.n = (N);  \\\r\n    p.other = calloc((N), sizeof*p.other);   \\\r\n    assert(p.other);\r\n\r\n    unsigned i, j;\r\n    for (i = 0; i < circle.n; ++i) {\r\n        MAKE_POINT(circle.points[i], i, circle.n - 1);\r\n    }\r\n    for (i = 0; i < circle.n; ++i) {\r\n        unsigned u = 0;\r\n        for (j = 0; j < circle.n; ++j) {\r\n            if (i == j)\r\n                continue;\r\n            circle.points[i].other[u++] = &circle.points[j];\r\n        }\r\n    }\r\n\r\n    FOR_ROOT_POINTER(&circle,\r\n        FLATTEN_STRUCT(figure, &circle);\r\n    );\r\n\r\n    for (i = 0; i < circle.n; ++i) {\r\n        free(circle.points[i].other);\r\n    }\r\n    free(circle.points);\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\nThe example code allows us to specify the number of points we want to process, e.g.:<br>\r\n```\r\n$ examples/circular-in 8\r\n```\r\nDepending on the size of available memory (and available disk space and time) we might set the value accordingly. For the following value we have got:<br>\r\n```\r\n$ examples/circular-in 10000\r\n# Flattening done. Summary:\r\n  Memory size: 800240031 bytes\r\n  Linked 100000002 pointers\r\n  Written 1600240087 bytes\r\n```\r\nOn the other side we will now read the entire image and try to calculate several properties of our close to circle polygon. These would be number of edges, sum of lengths of edges and diagonals and finally the approximated circumference (in the example we will walk through all the points and count the edges/diagonals and their lengths; after walking from point A to point B we will break the connection between B and A (by setting the B pointer to 0)):<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include <math.h>\r\n#include \"libflat.h\"\r\n\r\nstruct point {\r\n    double x;\r\n    double y;\r\n    unsigned n;\r\n    struct point** other;\r\n};\r\n\r\nstruct figure {\r\n    const char* name;\r\n    unsigned n;\r\n    struct point* points;\r\n};\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    const struct figure* circle = ROOT_POINTER_NEXT(const struct figure*);\r\n\r\n    unsigned i, j;\r\n    double length = 0, circumference = 0;\r\n    unsigned edge_number = 0;\r\n    for (i = 0; i < circle->n - 1; ++i) {\r\n        for (j = i; j < circle->n - 1; ++j) {\r\n            if (circle->points[i].other[j]) {\r\n\r\n                double path_len = sqrt( pow(circle->points[i].x-circle->points[i].other[j]->x, 2) +\r\n                        pow(circle->points[i].y-circle->points[i].other[j]->y, 2) );\r\n                length += path_len;\r\n\r\n                if (j == i)\r\n                    circumference += path_len;\r\n                if ((i == 0) && (j == circle->n - 2))\r\n                    circumference += path_len;\r\n\r\n                unsigned u;\r\n                for (u = 0; u < circle->n - 1; ++u) {\r\n                    if (circle->points[i].other[j]->other[u] == &circle->points[i]) {\r\n                        circle->points[i].other[j]->other[u] = 0;\r\n                    }\r\n                }\r\n                edge_number++;\r\n            }\r\n        }\r\n    }\r\n\r\n    printf(\"Number of edges/diagonals: %u\\n\", edge_number);\r\n    printf(\"Sum of lengths of edges/diagonals: %.17f\\n\", length);\r\n    printf(\"Half of the circumference: %.17f\\n\", circumference / 2);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\nRunning the example with warm caches yields:<br>\r\n```\r\n$ examples/circular-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.303173s\r\n  Fixing memory time: 0.112452s\r\n  Total time: 0.415674s\r\n  Total bytes read: 1600240087\r\nNumber of edges: 49995000\r\nSum of lengths of edges/diagonals: 63661976.71272929012775421\r\nHalf of the circumference: 3.14159260191227308\r\n```\r\nClearing the cache makes things slower as expected:<br>\r\n```\r\n$ echo 1 > /proc/sys/vm/drop_caches\r\n$ examples/circular-out\r\n# Unflattening done. Summary:\r\n  Image read time: 4.053782s\r\n  Fixing memory time: 0.114766s\r\n  Total time: 4.168599s\r\n  Total bytes read: 1600240087\r\n```\r\nAs showed it the example above unflattening depends mostly on the disk image read time and any further potential optimizations would need be focused on that part.<br>\r\n\r\n##Implementation details\r\n\r\nLibflat works by making copy of the process memory for indicated variables and structures. There are three main data structures fundamental to the Libflat operation, i.e.:\r\n* interval tree that holds information about fragments of memory image currently being flattened (implemented by the struct interval_tree_node structure);<br>\r\n* double linked list of binary data blocks that holds fragments of memory image currently being flattened (implemented by the structure struct blstream);<br>\r\n* red-black tree of fix-up information elements that hold information about parts of memory that need to be fixed (linked) after reading-in the memory image.<br>\r\n\r\nConsider the following example:<br>\r\n##Introduction\r\nLibflat is a library for fast serialization of C structures. Its main goal is speed (and of course correctness). Most of the time when you serialize your data the speed doesn't really matter (in contrast to other factors like simplicity, good coverage etc.). But there are cases when the speed is crucial, i.e. you're working with some big data sets and you need to serialize/deserialize them often (you might have some H/W device that produces a mass of data for further processing and you want to read in and analyze this data on another machine).<br>\r\n\r\nIn standard approach for serialization you pick up or design some protocol (e.g. based on JSON) and write the logic to save your structures. On the other side of the mirror you read in the packets, figure out what they represent and combine them to recreate your beloved data. This is fine. This works well. Unfortunately sometimes this works rather slow (rarely though and most of the time you can get away with it). Libflat is about to make this process as fast as possible by all cost.<br>\r\n\r\nGood example for using Libflat is Android build system (still based on Makefile build system as of Feb. 2016). Androd build system is monolithic which makes it extremely parallelizable.<br>\r\nThe main obstacle though (especially when you need to do lots of partial builds) is that you need to read all the makefiles up front (and there is lots of them). Trying it with hot caches gives the following (tests for android-6.0.0_r5)<br>\r\n```\r\n$ source build/envsetup.sh\r\n$ lunch aosp_arm64-eng\r\n$ time make\r\n============================================\r\nPLATFORM_VERSION_CODENAME=REL\r\nPLATFORM_VERSION=6.0\r\nTARGET_PRODUCT=aosp_arm64\r\nTARGET_BUILD_VARIANT=eng\r\nTARGET_BUILD_TYPE=release\r\nTARGET_BUILD_APPS=\r\nTARGET_ARCH=arm64\r\nTARGET_ARCH_VARIANT=armv8-a\r\nTARGET_CPU_VARIANT=generic\r\nTARGET_2ND_ARCH=arm\r\nTARGET_2ND_ARCH_VARIANT=armv7-a-neon\r\nTARGET_2ND_CPU_VARIANT=cortex-a15\r\nHOST_ARCH=x86_64\r\nHOST_OS=linux\r\nHOST_OS_EXTRA=Linux-3.13.0-58-generic-x86_64-with-Ubuntu-14.04-trusty\r\nHOST_BUILD_TYPE=release\r\nBUILD_ID=MRA58K\r\nOUT_DIR=out\r\n============================================\r\nincluding ./abi/cpp/Android.mk ...\r\nincluding ./art/Android.mk ...\r\nincluding ./bionic/Android.mk ...\r\n...\r\nincluding ./system/security/softkeymaster/Android.mk ...\r\nincluding ./system/vold/Android.mk ...\r\nincluding ./tools/external/fat32lib/Android.mk ...\r\n```\r\nSummary:<br>\r\n```\r\nreal    0m41.977s\r\nuser    0m32.590s\r\nsys     0m9.654s\r\n```\r\nNot so bad, especially when you have lots of RAM (so the only job that needs to be done is to parse all the Makefiles in memory using one thread). But what if we can omit the parsing phase at all and read in the whole memory content ready for going (or almost ready)?<br>\r\n\r\n##How Libflat works\r\n\r\nLibflat works by making copy of the process memory for indicated variables and structures. It doesn't matter whether original storage is automatic, static or allocated. The result is always stored on the heap (and kept on the heap after deserialization). Memory image is flat, i.e. whole copied memory image has continuous addresses. Pointers to original memory locations are properly resolved in the flattened image. Having whole memory serialized into one continuous memory block makes deserialization very fast (it is just a matter of reading entire block from disk to memory). Pointer resolution phase is needed after image is read in but this has linear complexity with number of pointers.<br>\r\n\r\nSimplest possible case of serialization can be made for automatic int variable as follows:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    int automatic = 0xDABBAD00;\r\n\r\n    FOR_ROOT_POINTER(&automatic,\r\n        FLATTEN_TYPE(int, &automatic);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/1-in\r\n# Flattening done. Summary:\r\n  Memory size: 4 bytes\r\n  Linked 0 pointers\r\n  Written 44 bytes\r\n```\r\nOn the other side reading the stored value can be now done by:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    int* now_allocated = ROOT_POINTER_NEXT(int*);\r\n    printf(\"%08X\\n\", *now_allocated);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/1-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000036s\r\n  Fixing memory time: 0.000000s\r\n  Total time: 0.000063s\r\n  Total bytes read: 44\r\nDABBAD00\r\n```\r\nSimilar procedure can be done with arrays and strings as in the below examples:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    int i;\r\n    const char* s = \"Fibonacci would not calculate this as fast\";\r\n    long fib[40] = { 0, 1 };\r\n    for (i = 2; i < 40; ++i)\r\n        fib[i] = fib[i - 1] + fib[i - 2];\r\n\r\n    FOR_ROOT_POINTER(fib,\r\n        FLATTEN_TYPE_ARRAY(long, fib, 40);\r\n    );\r\n\r\n    FOR_ROOT_POINTER(s,\r\n        FLATTEN_STRING(s);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/2-in\r\n# Flattening done. Summary:\r\n  Memory size: 363 bytes\r\n  Linked 0 pointers\r\n  Written 411 bytes\r\n```\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    long* fib = ROOT_POINTER_SEQ(long*, 0);\r\n    const char* s = ROOT_POINTER_SEQ(const char*, 1);\r\n\r\n    int i;\r\n    for (i = 0; i < 40; ++i)\r\n        printf(\"%ld \", fib[i]);\r\n    printf(\"\\n\");\r\n    printf(\"%s\\n\", s);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/2-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000055s\r\n  Fixing memory time: 0.000000s\r\n  Total time: 0.000100s\r\n  Total bytes read: 411\r\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 \r\nFibonacci would not calculate this as fast\r\n```\r\nThis brings the notion of the so called root pointer. When you read the contents of memory you will have a block of data to your disposal. But how to access it? You need some pointer to any part of this memory (assuming you can interpret the memory from this point and link to other parts). This is what the root pointer is for. It is just a pointer to some part of unflatten memory. This has its own storage and is not part of the memory image (but of course it is part of the image file).<br>\r\nLet's back to our first example. <br>\r\n```c\r\nint automatic = 0xDABBAD00;\r\n\r\nFOR_ROOT_POINTER(&automatic,\r\n    FLATTEN_TYPE(int, &automatic);\r\n);\r\n```\r\nWe simply told our flattener engine that we want to access the memory through the address of the \"automatic\" variable (i.e. we will hold it reference). Check out that flattened memory size is 4 c-bytes (which happens to be the sizeof(int) on my example making machine). But it doesn't need to be this way. We can modify the first example slightly and specify the root pointer address through some other pointer variable:\r\n```c\r\nint automatic = 0xDABBAD00;\r\nint* pi = &automatic;\r\n\r\nFOR_ROOT_POINTER(pi,\r\n    FLATTEN_TYPE(int, &automatic);\r\n);\r\n```\r\nAfter image read we just assign this value to our own defined variable as below:<br>\r\n```c\r\nint* now_allocated = ROOT_POINTER_NEXT(int*);\r\n```\r\nYou might have several root pointers to several parts of unflatten memory. To access them you simply call `ROOT_POINTER_NEXT` with proper type sequentially to receive one root pointer after another (you will get them in the order you did issue `FOR_ROOT_POINTER` macro in the first place). You can also retrieve root pointers as below:<br>\r\n```c\r\nconst char* s = ROOT_POINTER_SEQ(const char*, 1);\r\n```\r\nThis will read the second (with index 1) root pointer stored while creating memory image.<br>\r\n\r\nAs you might have noticed in order to flatten some type you will need a pointer to it. But what about pointers (or pointers to pointers etc.)? There is no difference as long as you have a pointer to it (or pointer to pointer to it). Huh?<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    double magic_number = 3.14159265359;\r\n    double* pointer_to_it = &magic_number;\r\n    double** pointer_to_pointer_to_it = &pointer_to_it;\r\n    double*** ehhh = &pointer_to_pointer_to_it;\r\n\r\n    FOR_ROOT_POINTER(ehhh,\r\n        FLATTEN_TYPE(double**, &pointer_to_pointer_to_it);\r\n        FOR_POINTER(double**,p, &pointer_to_pointer_to_it,\r\n            FLATTEN_TYPE(double*, p);\r\n            FOR_POINTER(double*, q, p,\r\n                FLATTEN_TYPE(double, q);\r\n            );\r\n        );\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/3-in\r\n# Flattening done. Summary:\r\n  Memory size: 24 bytes\r\n  Linked 2 pointers\r\n  Written 80 bytes\r\n```\r\nYou have just written three values into memory (two pointers and one double value). How so?<br>\r\n\r\nThe line:<br>\r\n```c\r\nFLATTEN_TYPE(double**, &pointer_to_pointer_to_it);\r\n```\r\nwrites the value pointed to by `&pointer_to_pointer_to_it` which is of type double** (this is the actual value stored in the `pointer_to_pointer_to_it` pointer). We did exactly the same in the first example:<br>\r\n```c\r\nFLATTEN_TYPE(int, &automatic);\r\n```\r\nWe wrote the value pointed to by `&automatic` which was of type int.<br>\r\n\r\nNext line:<br>\r\n```c\r\nFOR_POINTER(double**, p, &pointer_to_pointer_to_it,...);\r\n```\r\ntakes the actual value pointed to by `&pointer_to_pointer_to_it` and stores it in newly created variable `p` of appropriate type (double**). This variable must be pointer hence the macro name. New variable `p` (you can actually give it any accessible name) can be used in the block of code that follows (`...` macro arguments).<br>\r\n\r\nThe following code we does the same trick, i.e. writes the value pointed by `p` (of type double*):<br>\r\n```c\r\nFLATTEN_TYPE(double*, p);\r\n```\r\nFinally we create another variable `q` that acquires the value pointed by `p` (which finally points to the magic double value) and writes the double number to the memory image:<br>\r\n```c\r\nFOR_POINTER(double*, q, p,\r\n    FLATTEN_TYPE(double, q);\r\n);\r\n```\r\nChecking the stored value confirms our words:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    double*** ehhh = ROOT_POINTER_SEQ(double***, 0);\r\n    printf(\"The magic answer to the ultimate question of life?: %f\\n\", ***ehhh);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/3-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000058s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000105s\r\n  Total bytes read: 80\r\nThe magic answer to the ultimate question of life?: 3.141593\r\n```\r\nIn the write output you can now see the line that says:<br>\r\n```\r\nLinked 2 pointers\r\n```\r\nThe memory image contained two pointers as we just explained. But after reading them in in the second process (which could actually happened on different computer on diffrenent continent) the pointer values would not probably have any proper meaning in the context of new process address space. That's why we need to fix them.<br>\r\n\r\nConsider the following block of code:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    static char carr[] = \"You don't need to be great to start, \"\r\n            \"but you need to start to be great\";\r\n\r\n    const char* start = carr;\r\n    const char* middle = carr + 41;\r\n\r\n    FOR_ROOT_POINTER(start,\r\n        FLATTEN_TYPE(const char*, &start);\r\n        FOR_POINTER(const char*, s, &start,\r\n            FLATTEN_STRING(s);\r\n        );\r\n    );\r\n\r\n    FOR_ROOT_POINTER(middle,\r\n        FLATTEN_TYPE(const char*, &middle);\r\n        FOR_POINTER(const char*, s, &middle,\r\n            FLATTEN_STRING(s);\r\n        );\r\n    );\r\n\r\n    printf(\"&carr[0]: %p\\n\", &carr[0]);\r\n    printf(\"&start: %p -> %p\\n\", &start, start);\r\n    printf(\"&middle: %p -> %p\\n\", &middle, middle);\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\nAnd the result of running it:<br>\r\n```\r\n$ examples/4-in\r\n&carr[0]: 0x6020c0\r\n&start: 0x7fff9da3a8c0 -> 0x6020c0\r\n&middle: 0x7fff9da3a8c8 -> 0x6020e9\r\n# Flattening done. Summary:\r\n  Memory size: 87 bytes\r\n  Linked 2 pointers\r\n  Written 151 bytes\r\n```\r\nThe original memory looks as follows:<br>\r\n\r\nSomewhere in the static memory area:<br>\r\n```\r\n0x6020c0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0]\r\n                                 ^\r\n                                 0x6020e9\r\n```\r\nSomewhere on the stack:<br>\r\n```\r\n0x7fff9da3a8c0: [0x6020c0|0x6020e9]\r\n```\r\nLibflat will arrange memory image in ascending order of original addresses:<br>\r\n```\r\n[Y|o|u|...|g|r|e|a|t|0|0x6020c0|0x6020e9]\r\n```\r\nand replace original pointer values with its position independent counterparts (independent from the starting address of the memory image in the process address space):<br>\r\n```\r\n[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029]\r\n ^                     ^\r\n 0x000000              0x000029\r\n```\r\nIt also needs to store two additional values, i.e. at which offset in the flattened memory area actual pointers appears (as we need to find them later):<br>\r\n```\r\n[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f]\r\n                                             ^        ^\r\n                                             0x47     0x4f\r\n```\r\nFinally it also stores two root pointers (start and middle pointer values) as the offsets in the flattened memory image for later retrieval:<br>\r\n```\r\n[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f] [0x47,0x4f]\r\n                                                                             ^    ^\r\n                                                                             start offset\r\n                                                                                  ^\r\n                                                                                  middle offset\r\n```\r\nIn this example we have only two pointers and both of them are root pointers therefore stored values are duplicated. In real life scenarios we will probably have much more standard pointers and very few root pointers (as all must be manually setup by programmer).<br>\r\n\r\nDuring unflattening stage (as in the below example) several things happen.<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    const char* start = ROOT_POINTER_SEQ(const char*, 0);\r\n    const char* middle = ROOT_POINTER_SEQ(const char*, 1);\r\n\r\n    printf(\"&start: %p -> %p\\n\", &start, start);\r\n    printf(\"&middle: %p -> %p\\n\", &middle, middle);\r\n    const void* ptr1 = start + strlen(start) + 1;\r\n    printf(\"*(%p) => %p\\n\", ptr1, *(void**) ptr1);\r\n    const void* ptr2 = start + strlen(start) + 1 + sizeof(const char*);\r\n    printf(\"*(%p) => %p\\n\", ptr2, *(void**) ptr2);\r\n    printf(\"%s\\n\", start);\r\n    printf(\"Remember: %s\\n\", middle);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/4-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000037s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000068s\r\n  Total bytes read: 151\r\n&start: 0x7ffe7454eae0 -> 0x8de2a0\r\n&middle: 0x7ffe7454eae8 -> 0x8de2c9\r\n*(0x8de2e7) => 0x8de2a0\r\n*(0x8de2ef) => 0x8de2c9\r\nYou don't need to be great to start, but you need to start to be great\r\nRemember: you need to start to be great\r\n```\r\nNew memory area is created in the allocated storage area (the heap) and memory image is read in:<br>\r\n```\r\n0x8de2a0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f] [0x47,0x4f]\r\n                                 ^\r\n                                 0x8de2c9\r\n```\r\nNow we read two pointer offsets (0x47 and 0x4f) and fix two pointers at these offsets by adding the initial address of the allocated memory area to the position independent pointer value:<br>\r\n```\r\n0x8de2a0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x8de2a0|0x8de2c9] [0x47,0x4f] [0x47,0x4f]\r\n                                 ^                     ^        ^         ^ pointer offset array\r\n                                 0x8de2c9              0x47     0x4f                   ^\r\n                                                       ^        ^                      root pointer offset array\r\n                                                       0x8de2e7 0x8de2ef\r\n```\r\nNow the first pointer points at the beginning of the string and second points in the middle. This process is called linking and this is what the line `Linked 2 pointers` was talking about.<br>\r\n\r\nFinally we read two root pointers at offset location 0x47 and 0x4f which happens to be the same values as the only two pointers, create their storage and set the translated values:<br>\r\n```\r\n&start: 0x7ffe7454eae0 -> 0x8de2a0\r\n&middle: 0x7ffe7454eae8 -> 0x8de2c9\r\n```\r\nTo finally confirm the example we will move start pointer (and the second pointer) by the length of the string and read the value stored at the resulting location:<br>\r\n```c\r\nconst void* ptr1 = start + strlen(start) + 1;\r\nprintf(\"*(%p) => %p\\n\", ptr1, *(void**)ptr1);\r\nconst void* ptr2 = start + strlen(start) + 1 + sizeof(const char*);\r\nprintf(\"*(%p) => %p\\n\", ptr2, *(void**)ptr2);\r\n```\r\n```\r\n*(0x8de2e7) => 0x8de2a0\r\n*(0x8de2ef) => 0x8de2c9\r\n```\r\nThere is actually more you can do with pointers. For instance you can manage arrays of pointers in similar fashion:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    const char* argv[] = { \"Program name\", \"Argument 0\", \"Argument 1\",\r\n            \"Argument 2\", \"Argument 3\", 0 };\r\n\r\n    FOR_ROOT_POINTER(argv,\r\n        FOREACH_POINTER(const char*, arg, argv,\r\n                ptrarrmemlen((const void * const*)argv),\r\n            FLATTEN_TYPE(const char*, arg);\r\n            FLATTEN_STRING(arg);\r\n        );\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/5-in\r\n# Flattening done. Summary:\r\n  Memory size: 105 bytes\r\n  Linked 5 pointers\r\n  Written 185 bytes\r\n```\r\nHere, for each pointer in the array `argv` we create temporary variable `arg` of type `const char*` which we can use in the subsequent block of code. We must specify the size of the array. We might know it in advance or we can compute it in real time. In case of arrays terminated with pointer 0 (NULL pointer) there is function `ptrarrmemlen` available for this purpose. It simply iterates through entire pointer array and counts the pointers until it reaches the pointer 0 (and counts it as well). Similar function is used internally by the `FLATTEN_STRING` macro, i.e. `strmemlen` function which returns the length of string including NULL terminating 0 value.<br>\r\n\r\nIn the code body we first flatten the pointer itself and then we flatten the string pointed to by it.<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    const char** argv = ROOT_POINTER_NEXT(const char**);\r\n    while (*argv) {\r\n        printf(\"%s\\n\", *argv);\r\n        argv++;\r\n    }\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n$ examples/5-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000057s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000104s\r\n  Total bytes read: 185\r\nProgram name\r\nArgument 0\r\nArgument 1\r\nArgument 2\r\nArgument 3\r\n```\r\nWe finally came to the last (and most interesting) part where all the fun really begins, i.e. flattening C structures. Flattening C structure is as simple as:<br>\r\n```c\r\nFLATTEN_STRUCT(type, pointer);\r\n```\r\nHowever you have to provide recipe how to actually flatten structure internal fields. In the below example we want to flatten structure `figure` (which happens to be a square):<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nstruct point {\r\n    double x;\r\n    double y;\r\n};\r\n\r\nstruct edge {\r\n    struct point p[2];\r\n    struct edge* e;\r\n};\r\n\r\nstruct figure {\r\n    const char* name;\r\n    struct edge* e;\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(figure);\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    struct point sqv[4] = {{1.0, 1.0}, {1.0, -1.0}, {-1.0, -1.0}, {-1.0, 1.0}};\r\n    struct edge sqe[4] = {\r\n            { {sqv[0],sqv[1]}, &sqe[1] },\r\n            { {sqv[1],sqv[2]}, &sqe[2] },\r\n            { {sqv[2],sqv[3]}, &sqe[3] },\r\n            { {sqv[3],sqv[0]}, &sqe[0] }\r\n    };\r\n\r\n    struct figure square = { \"square\", sqe };\r\n\r\n    printf(\"sizeof(struct figure): %zu\\n\", sizeof(struct figure));\r\n\r\n    FOR_ROOT_POINTER(&square,\r\n        FLATTEN_STRUCT(figure, &square);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/6-in_a\r\nsizeof(struct figure): 16\r\n# Flattening done. Summary:\r\n  Memory size: 16 bytes\r\n  Linked 0 pointers\r\n  Written 56 bytes\r\n```\r\nAs we can see the structure has been actually flattened but quick glance reveals that not everything might have gone as expected. We have just written 16 bytes (the size of the structure) itself but no internal fields has been touched (and they will point to the vain after reading them out).<br>\r\n\r\nThe function providing the recipe how to flatten internal structure fields is called `FUNCTION_DEFINE_FLATTEN_STRUCT`. We should provide the type of the structure and the code responsible for writing structure content. Let's workout the example a little more and add the following functions:<br>\r\n```c\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(edge,\r\n    AGGREGATE_FLATTEN_STRUCT(edge, e);\r\n);\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(figure,\r\n    AGGREGATE_FLATTEN_STRING(name);\r\n    AGGREGATE_FLATTEN_STRUCT(edge, e);\r\n);\r\n```\r\n```\r\n$ examples/6-in_b\r\nsizeof(struct figure): 16\r\n# Flattening done. Summary:\r\n  Memory size: 183 bytes\r\n  Linked 6 pointers\r\n  Written 271 bytes\r\n```\r\nVoila! By adding several lines of code we managed to write down the whole figure properly resolving all pointers along the way.<br>\r\nSo far we have seen several functions for writing memory image, i.e.:<br>\r\n```c\r\nFLATTEN_STRING(pointer)\r\nFLATTEN_TYPE(type, pointer)\r\nFLATTEN_TYPE_ARRAY(type, pointer, size)\r\nFLATTEN_STRUCT(type, pointer)\r\n```\r\nThere is one more function we can use to save memory structures:<br>\r\n```c\r\nFLATTEN_STRUCT_ARRAY(type, pointer, size)\r\n```\r\nIt's actually a convenience function that takes the burden of serializing a structure array pointer by pointer off from the user. It is needed to bring the following definition when using it:<br>\r\n```c\r\nINLINE_FUNCTION_DEFINE_FLATTEN_STRUCT_ARRAY(type)\r\n```\r\nEach of these five functions has so called AGGREGATE counterparts, i.e.:<br>\r\n```c\r\nAGGREGATE_FLATTEN_STRING(field)\r\nAGGREGATE_FLATTEN_TYPE(type, field)\r\nAGGREGATE_FLATTEN_TYPE_ARRAY(type, field, size)\r\nAGGREGATE_FLATTEN_STRUCT(type, field)\r\nAGGREGATE_FLATTEN_STRUCT_ARRAY(type, field, size)\r\n```\r\nInstead of pointer to variable we use the corresponding field name from within the structure.<br>\r\n\r\nIf we want to use the field name itself for other purpose (i.e. length of the array for some other structure field) we have available macro:<br>\r\n```c\r\nATTR(field)\r\n```\r\nFinally to bring the structure flattening functions declarations across translation units we can use macro:<br>\r\n```c\r\nFUNCTION_DECLARE_FLATTEN_STRUCT(type)\r\n```\r\nPlease note that in the above example we didn't write function recipe for flattening the `struct point`. We also omitted field `p` from the `struct edge`. These values are part of internal structure storage (they are not pointers) therefore there's no need for recursive resolution of those fields (they will be flattened together with the original structure storage).<br>\r\n\r\nReading up the square structure from memory image is straightforward:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include <math.h>\r\n#include \"libflat.h\"\r\n\r\nstruct point {\r\n    double x;\r\n    double y;\r\n};\r\n\r\nstruct edge {\r\n    struct point p[2];\r\n    struct edge* e;\r\n};\r\n\r\nstruct figure {\r\n    const char* name;\r\n    struct edge* e;\r\n};\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    const struct figure* square = ROOT_POINTER_NEXT(const struct figure*);\r\n\r\n    struct edge* e = square->e;\r\n    double circumference = 0;\r\n    do {\r\n        circumference += sqrt(\r\n                pow(e->p[0].x - e->p[1].x, 2) + pow(e->p[0].y - e->p[1].y, 2));\r\n        e = e->e;\r\n    } while (e != square->e);\r\n\r\n    printf(\"%s circumference: %f\\n\", square->name, circumference);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/6-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000051s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000095s\r\n  Total bytes read: 271\r\nsquare circumference: 8.000000\r\n```\r\nIt would be also possible to flatten the entire structure with all links using mere pointer flattening functions but in that case we would need to implement the recursive structure member resolution by ourselves:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nstruct point {\r\n    double x;\r\n    double y;\r\n};\r\n\r\nstruct edge {\r\n    struct point p[2];\r\n    struct edge* e;\r\n};\r\n\r\nstruct figure {\r\n    const char* name;\r\n    struct edge* e;\r\n};\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    struct point sqv[4] = {{1.0, 1.0}, {1.0, -1.0}, {-1.0, -1.0}, {-1.0, 1.0}};\r\n    struct edge sqe[4] = {\r\n            { {sqv[0],sqv[1]}, &sqe[1] },\r\n            { {sqv[1],sqv[2]}, &sqe[2] },\r\n            { {sqv[2],sqv[3]}, &sqe[3] },\r\n            { {sqv[3],sqv[0]}, &sqe[0] }\r\n    };\r\n\r\n    struct figure square = { \"square\", sqe };\r\n\r\n    printf(\"sizeof(struct figure): %zu\\n\", sizeof(struct figure));\r\n\r\n    FOR_ROOT_POINTER(&square,\r\n        FOR_POINTER(const char*, n, &square.name,\r\n            FLATTEN_STRING(n);\r\n        );\r\n        FOR_POINTER(const char*, n, &square.e,\r\n            FLATTEN_TYPE(struct edge*,n);\r\n        );\r\n        struct edge* e = square.e;\r\n        do {\r\n            FOR_POINTER(struct edge*, pe, &e->e,\r\n                FLATTEN_TYPE_ARRAY(struct point,pe->p, 2);\r\n                FLATTEN_TYPE(struct edge*, pe);\r\n            );\r\n            e = e->e;\r\n        } while(e!=square.e);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/6-in_c\r\nsizeof(struct figure): 16\r\n# Flattening done. Summary:\r\n  Memory size: 183 bytes\r\n  Linked 6 pointers\r\n  Written 271 bytes\r\n```\r\nIn the final example we will try to pressure the library a little bit and notice how it responds to more demanding job. Let's modify the previous example and try to approximate a circle. To avoid stack overflow (in the previous example walking through the edges during flattening stage required one recursive call deeper per each edge) we will modify the structures slightly. `struct figure` will hold a table of all points and each point will hold a pointer to each other point in the polygon. We will build regular polygon with points around the circle circumference of radius 1. When number of points is 8 it would look something like below:<br>\r\n\r\n![Figure 1.](https://github.com/braton/libflat/blob/gh-pages/images/figure_1.png)\r\n\r\nWe will describe the flattening recipe for each structure as in the full example below:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <math.h>\r\n#include \"libflat.h\"\r\n\r\nstruct point {\r\n    double x;\r\n    double y;\r\n    unsigned n;\r\n    struct point** other;\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(point,\r\n    AGGREGATE_FLATTEN_TYPE_ARRAY(struct point*, other, ATTR(n));\r\n    FOREACH_POINTER(struct point*, p, ATTR(other), ATTR(n),\r\n            FLATTEN_STRUCT(point, p);\r\n    );\r\n);\r\n\r\nstruct figure {\r\n    const char* name;\r\n    unsigned n;\r\n    struct point* points;\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(figure,\r\n    AGGREGATE_FLATTEN_STRING(name);\r\n    AGGREGATE_FLATTEN_STRUCT_ARRAY(point,points,ATTR(n));\r\n);\r\n\r\nint main(int argc, char** argv) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    assert(argc > 1);\r\n    struct figure circle = { \"circle\" };\r\n    assert(sscanf(argv[1], \"%u\", &circle.n) == 1);\r\n    assert(circle.n > 1);\r\n    circle.points = calloc(circle.n, sizeof(struct point));\r\n    assert(circle.points);\r\n    double radius = 1.0, angle = 2 * M_PI / circle.n;\r\n\r\n#define MAKE_POINT(p, i, N)   \\\r\n    p.x = cos(angle*(radius*(i)));  \\\r\n    p.y = sin(angle*(radius*(i)));  \\\r\n    p.n = (N);  \\\r\n    p.other = calloc((N), sizeof*p.other);   \\\r\n    assert(p.other);\r\n\r\n    unsigned i, j;\r\n    for (i = 0; i < circle.n; ++i) {\r\n        MAKE_POINT(circle.points[i], i, circle.n - 1);\r\n    }\r\n    for (i = 0; i < circle.n; ++i) {\r\n        unsigned u = 0;\r\n        for (j = 0; j < circle.n; ++j) {\r\n            if (i == j)\r\n                continue;\r\n            circle.points[i].other[u++] = &circle.points[j];\r\n        }\r\n    }\r\n\r\n    FOR_ROOT_POINTER(&circle,\r\n        FLATTEN_STRUCT(figure, &circle);\r\n    );\r\n\r\n    for (i = 0; i < circle.n; ++i) {\r\n        free(circle.points[i].other);\r\n    }\r\n    free(circle.points);\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\nThe example code allows us to specify the number of points we want to process, e.g.:<br>\r\n```\r\n$ examples/circular-in 8\r\n```\r\nDepending on the size of available memory (and available disk space and time) we might set the value accordingly. For the following value we have got:<br>\r\n```\r\n$ examples/circular-in 10000\r\n# Flattening done. Summary:\r\n  Memory size: 800240031 bytes\r\n  Linked 100000002 pointers\r\n  Written 1600240087 bytes\r\n```\r\nOn the other side we will now read the entire image and try to calculate several properties of our close to circle polygon. These would be number of edges, sum of lengths of edges and diagonals and finally the approximated circumference (in the example we will walk through all the points and count the edges/diagonals and their lengths; after walking from point A to point B we will break the connection between B and A (by setting the B pointer to 0)):<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include <math.h>\r\n#include \"libflat.h\"\r\n\r\nstruct point {\r\n    double x;\r\n    double y;\r\n    unsigned n;\r\n    struct point** other;\r\n};\r\n\r\nstruct figure {\r\n    const char* name;\r\n    unsigned n;\r\n    struct point* points;\r\n};\r\n\r\nint main(void) {\r\n\r\n    FILE* in = fopen(\"/tmp/memory.img\", \"r\");\r\n    assert(in);\r\n    unflatten_init();\r\n\r\n    assert(unflatten_read(in) == 0);\r\n\r\n    const struct figure* circle = ROOT_POINTER_NEXT(const struct figure*);\r\n\r\n    unsigned i, j;\r\n    double length = 0, circumference = 0;\r\n    unsigned edge_number = 0;\r\n    for (i = 0; i < circle->n - 1; ++i) {\r\n        for (j = i; j < circle->n - 1; ++j) {\r\n            if (circle->points[i].other[j]) {\r\n\r\n                double path_len = sqrt( pow(circle->points[i].x-circle->points[i].other[j]->x, 2) +\r\n                        pow(circle->points[i].y-circle->points[i].other[j]->y, 2) );\r\n                length += path_len;\r\n\r\n                if (j == i)\r\n                    circumference += path_len;\r\n                if ((i == 0) && (j == circle->n - 2))\r\n                    circumference += path_len;\r\n\r\n                unsigned u;\r\n                for (u = 0; u < circle->n - 1; ++u) {\r\n                    if (circle->points[i].other[j]->other[u] == &circle->points[i]) {\r\n                        circle->points[i].other[j]->other[u] = 0;\r\n                    }\r\n                }\r\n                edge_number++;\r\n            }\r\n        }\r\n    }\r\n\r\n    printf(\"Number of edges/diagonals: %u\\n\", edge_number);\r\n    printf(\"Sum of lengths of edges/diagonals: %.17f\\n\", length);\r\n    printf(\"Half of the circumference: %.17f\\n\", circumference / 2);\r\n\r\n    unflatten_fini();\r\n    fclose(in);\r\n\r\n    return 0;\r\n}\r\n```\r\nRunning the example with warm caches yields:<br>\r\n```\r\n$ examples/circular-out\r\n# Unflattening done. Summary:\r\n  Image read time: 0.303173s\r\n  Fixing memory time: 0.112452s\r\n  Total time: 0.415674s\r\n  Total bytes read: 1600240087\r\nNumber of edges: 49995000\r\nSum of lengths of edges/diagonals: 63661976.71272929012775421\r\nHalf of the circumference: 3.14159260191227308\r\n```\r\nClearing the cache makes things slower as expected:<br>\r\n```\r\n$ echo 1 > /proc/sys/vm/drop_caches\r\n$ examples/circular-out\r\n# Unflattening done. Summary:\r\n  Image read time: 4.053782s\r\n  Fixing memory time: 0.114766s\r\n  Total time: 4.168599s\r\n  Total bytes read: 1600240087\r\n```\r\nAs showed it the example above unflattening depends mostly on the disk image read time and any further potential optimizations would need be focused on that part.<br>\r\n\r\n##Implementation details\r\n\r\nLibflat works by making copy of the process memory for indicated variables and structures. There are three main data structures fundamental to the Libflat operation, i.e.:\r\n* interval tree that holds information about fragments of memory image currently being flattened (implemented by the `struct interval_tree_node` structure);<br>\r\n* double linked list of binary data blocks that holds fragments of memory image currently being flattened (implemented by the structure `struct blstream`);<br>\r\n* red-black tree of fix-up information elements that hold information about parts of memory that need to be fixed (linked) after reading-in the memory image.<br>\r\n\r\nConsider the following example:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <limits.h>\r\n#include \"libflat.h\"\r\n\r\nstruct internal_type {\r\n    int u:4;\r\n    char c;\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(internal_type);\r\n\r\nstruct type {\r\n    const char* name;\r\n    unsigned long v;\r\n    struct type* next;\r\n    struct internal_type* internal[4];\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(type,\r\n    AGGREGATE_FLATTEN_STRING(name);\r\n    AGGREGATE_FLATTEN_STRUCT(type, next);\r\n    FOREACH_POINTER(struct internal_type*, p, ATTR(internal), 4,\r\n        FLATTEN_STRUCT(internal_type, p);\r\n    );\r\n);\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    char* st[] = {\r\n        \"string0\",\r\n        \"string1\",\r\n        \"string2\",\r\n        0\r\n    };\r\n\r\n    static struct internal_type u = { .u=1, .c='#' };\r\n    static struct internal_type w = { .u=2, .c='@' };\r\n\r\n    struct type* alloc_type = calloc(1, sizeof(struct type));\r\n        alloc_type->name = st[2] + 2;\r\n        alloc_type->next = alloc_type;\r\n        alloc_type->internal[0] = &u;\r\n        alloc_type->internal[1] = &w;\r\n\r\n    struct type type_arr[2] = {\r\n            { .name=\"type1\", .v=UINT_MAX, &type_arr[1], {&u, &u, 0, 0}  },\r\n            {  st[1], .v=0, alloc_type, {0} }\r\n    };\r\n\r\n    struct type* root_ptr = &type_arr[0];\r\n\r\n    FOR_ROOT_POINTER(root_ptr,\r\n        FLATTEN_STRUCT(type, root_ptr);\r\n    );\r\n\r\n    FOR_ROOT_POINTER(st,\r\n        FOREACH_POINTER(const char*, s, st, ptrarrmemlen((const void* const*)st),\r\n            FLATTEN_STRING(s);\r\n        );\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n    free(alloc_type);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/7-in\r\n(...)\r\n```\r\nLet's draw the original memory image that is about to be serialized. It might look like below.<br>\r\n```\r\n(automatic storage)\r\n\r\nst:         [    0x401a53    ][    0x401a5b    ][    0x401a63    ][ 0 ]\r\n            ^                 ^                 ^                 ^\r\n            0x7ffec43881e0    0x7ffec43881e8    0x7ffec43881f0    0x7ffec43881f8\r\nw:          [ 4B ]\r\n            ^\r\n            0x7ffec43881d0\r\ntype_arr:   [ ...  56B  ... ][ ...  56B  ... ]\r\n            ^                ^\r\n            0x7ffec4388200   0x7ffec4388238\r\n\r\n(allocated storage)\r\n\r\nalloc_type: [ ...  56B  ... ]\r\n            ^\r\n            0x101e250\r\n\r\n(static storage)\r\n\r\nst[0]:      ['s'|'t'|'r'|'i'|'n'|'g'|'0'|0]\r\n            ^\r\n            0x401a53\r\n\r\nst[1]:      ['s'|'t'|'r'|'i'|'n'|'g'|'1'|0]\r\n            ^\r\n            0x401a5b\r\n\r\nst[2]:      ['s'|'t'|'r'|'i'|'n'|'g'|'2'|0]\r\n            ^\r\n            0x401a63\r\n\r\nu:          [ 4B ]\r\n            ^\r\n            0x6030f8\r\n\r\ntype_arr[0].name:   ['t'|'y'|'p'|'e'|'1'|0]\r\n                    ^\r\n                    0x401a6b\r\n```\r\nFirst item that goes through flattening is the structure pointed by `root_ptr (&type_arr[0])`. This happens in the macro:<br>\r\n```c\r\nFLATTEN_STRUCT(type, root_ptr);\r\n```\r\nIf we expand this macro we might see the following code:<br>\r\n```c\r\nstruct flatten_pointer* __fptr = make_flatten_pointer(0, 0);\r\nif (root_ptr) {\r\n    fixup_set_insert(__fptr->node, __fptr->offset, flatten_struct_type((root_ptr)));\r\n}\r\nfree(__fptr);\r\n```\r\nThe function `flatten_struct_type` is defined by the `FUNCTION_DEFINE_FLATTEN_STRUCT(type,...)` macro and takes the pointer to `struct type` that is about to be flattened as a parameter. The first thing it does is to create new interval fragment in the memory interval tree that corresponds to this structure location:<br>\r\n```\r\n[0x7ffec4388200:0x7ffec4388237] => [ 56B ]\r\n^                                  ^\r\n0x101e2b0                          0x101e2f0\r\n```\r\nThis interval is described by `struct interval_tree_node` structure, specifically by its `start` and `last` fields. Furthermore it also holds pointer to the underlying data (the copied contents from the original structure location) through `struct blstream` instance.<br>\r\n\r\nIn the next step it recursively calls all flattening functions defined as recipes for flattening this structure internal storage (e.g. memory pointed to by this structure internal pointers). In our case the first recursive call is `AGGREGATE_FLATTEN_STRING(name)`. Expanding it again we have:<br>\r\n\r\nif (_ptr->name) {\r\n    fixup_set_insert(__node, offsetof(struct type, name), flatten_plain_type(_ptr->name, strmemlen(_ptr->name)));\r\n}\r\n\r\n`_ptr` now points to the original structure;<br>\r\n`__node` is the newly created interval for the original structure (described above).<br>\r\n\r\n`flatten_plain_type` does similar thing as `flatten_struct_type` with the difference that it can take arbitrary memory block of specified size (and will not call any functions recursively as the content of string does not normally contain pointers to other memory regions). In our case we have string `type1` of total size 6 therefore new memory fragment of size 6 is created (we have now two memory fragments):<br>\r\n```\r\n[0x7ffec4388200:0x7ffec4388237] => [ 56B ]\r\n[0x401a6b:0x401a70] => [ 6B ]\r\n^                      ^\r\n0x101e360              0x101e3a0\r\n```\r\nThis process continues recursively for all recipes embedded into structure flattening recipes (and pointer flattening recipes, i.e. `FOREACH_POINTER`):<br>\r\n```c\r\nAGGREGATE_FLATTEN_STRUCT(type, next);\r\nFOREACH_POINTER(struct internal_type*, p, ATTR(internal), 4,\r\n    FLATTEN_STRUCT(internal_type, p);\r\n);\r\n```\r\nEach call creates another interval fragment of original memory (and corresponding copied memory data block). If memory fragment already exists (or partially exists) it is ignored (or another memory fragment that fills the remaining memory is created). For example flattening stage in our example looks like below (you can always check how flattening stage operates by invoking `flatten_set_debug_flag(1)` before the actual serialization):<br>\r\n```\r\n(Executed function)                                     (function argument)       (created interval)\r\nFOR_ROOT_POINTER(root_ptr)\r\n  FLATTEN_STRUCT(type, root_ptr)                         {root_ptr}                [0x7ffec4388200:0x7ffec4388237] => [ 56B ]\r\n    AGGREGATE_FLATTEN_STRING(name)                       {name: \"type1\"}           [0x401a6b:0x401a70] => [ 6B ]\r\n    AGGREGATE_FLATTEN_STRUCT(type, next)                 {next: &type_arr[1]}      [0x7ffec4388238:0x7ffec438826f] => [ 56B ]\r\n      AGGREGATE_FLATTEN_STRING(name)                     {name: st[1]}             [0x401a5b:0x401a62] => [ 8B ]\r\n      AGGREGATE_FLATTEN_STRUCT(type, next)               {alloc_type}              [0x101e250:0x101e287] => [ 56B ]\r\n        AGGREGATE_FLATTEN_STRING(name)                   {st[2]+2}                 [0x401a65:0x401a6a] => [ 6B ]\r\n        AGGREGATE_FLATTEN_STRUCT(type, next)             {alloc_type}              <EXISTS>\r\n        FOREACH_POINTER(struct internal_type*, p,\r\n                                ((_ptr)->internal), 4)\r\n          FLATTEN_STRUCT(internal_type, p)               {&u}                      [0x6030f8:0x6030fb] => [ 4B ]\r\n          FLATTEN_STRUCT(internal_type, p)               {&w}                      [0x7ffec43881d0:0x7ffec43881d3] => [ 4B ]\r\n          FLATTEN_STRUCT(internal_type, p)               {0}                       <NULL>\r\n          FLATTEN_STRUCT(internal_type, p)               {0}                       <NULL>\r\n      FOREACH_POINTER(struct internal_type*, p,\r\n                              ((_ptr)->internal), 4)\r\n        FLATTEN_STRUCT(internal_type, p)                 {0}                       <NULL>\r\n        FLATTEN_STRUCT(internal_type, p)                 {0}                       <NULL>\r\n        FLATTEN_STRUCT(internal_type, p)                 {0}                       <NULL>\r\n        FLATTEN_STRUCT(internal_type, p)                 {0}                       <NULL>\r\n    FOREACH_POINTER(struct internal_type*, p,\r\n                            ((_ptr)->internal), 4)\r\n      FLATTEN_STRUCT(internal_type, p)                   {&u}                      <EXISTS>\r\n      FLATTEN_STRUCT(internal_type, p)                   {&w}                      <EXISTS>\r\n      FLATTEN_STRUCT(internal_type, p)                   {0}                       <NULL>\r\n      FLATTEN_STRUCT(internal_type, p)                   {0}                       <NULL>\r\n\r\nFOR_ROOT_POINTER(st)\r\n  FOREACH_POINTER(const char*, s, st,\r\n                ptrarrmemlen((const void* const*)st))   {&st[0]}                  [0x7ffec43881e0:0x7ffec43881e7] => [ 8B ]\r\n                                                        {&st[1]}                  [0x7ffec43881e8:0x7ffec43881ef] => [ 8B ]\r\n                                                        {&st[2]}                  [0x7ffec43881f0:0x7ffec43881f7] => [ 8B ]\r\n                                                        {&st[3]}                  [0x7ffec43881f8:0x7ffec43881ff] => [ 8B ]\r\n\r\n    FLATTEN_STRING(s)                                   {st[0]}                   [0x401a53:0x401a5a] => [ 8B ]\r\n    FLATTEN_STRING(s)                                   {st[1]}                   <EXISTS>\r\n    FLATTEN_STRING(s)                                   {st[2]}                   [0x401a63:0x401a64] => [ 2B ]\r\n    FLATTEN_STRING(s)                                   {0}                       <NULL>\r\n```\r\nYou can notice that `alloc_type->name` points inside the string `string2`. During serialization of this member only 6B of this string are written:<br>\r\n```\r\nAGGREGATE_FLATTEN_STRING(name)                  {st[2] + 2}                 [0x401a65:0x401a6a] => [ 6B ]\r\n```\r\nRemaining two bytes are added when the `string2` string is serialized from its beginning (parts of this string already available in memory image are omitted):<br>\r\n```\r\nFLATTEN_STRING(s)                                   {st[2]}                   [0x401a63:0x401a64] => [ 2B ]\r\n```\r\nIt's worth to notice that function `FOREACH_POINTER` also dumps the storage of a pointer its creates before making it available for internal recipes as in:<br>\r\n```c\r\nFOREACH_POINTER(const char*, s, st,...)\r\n```\r\nunless it's already been flattened as in:<br>\r\n```c\r\nFOREACH_POINTER(struct internal_type*, p,...)\r\n```\r\nwhich has been flattened as a part of the storage of the encompassing structure type (the pointer itself is a part of the structure storage).<br>\r\n\r\nAs has been mentioned each interval structure holds pointer (`struct blstream*`) to corresponding binary data block of copied memory. All blocks are arranged in doubly linked list (in sorted order by its initial addresses) which makes adding new block anywhere in the list a fast operation (constant time).<br>\r\n\r\nConsidering the example above before executing:<br>\r\n```\r\nFLATTEN_STRING(s)                                   {st[2]}                   [0x401a63:0x401a64] => [ 2B ]\r\n```\r\nthe memory data list would look as follows:<br>\r\n```\r\n[ 8B ]              [ 8B ]              [ 6B ]              [ 6B ]              [ 4B ]              [ 56B ]\r\n0x101ec60           0x101e540           0x101e6e0           0x101e3a0           0x101e850           0x101e630\r\n^                   ^                   ^                   ^                   ^                   ^\r\n[0x401a53:0x401a5a] [0x401a5b:0x401a62] [0x401a65:0x401a6a] [0x401a6b:0x401a70] [0x6030f8:0x6030fb] [0x101e250:0x101e287]\r\n^                   ^                   ^                   ^                   ^                   ^\r\n0x101ec20           0x101e500           0x101e6a0           0x101e360           0x101e810           0x101e5f0\r\n\r\n\r\n[ 4B ]                          [ 8B ]                          [ 8B ]                          [ 8B ]                          [ 8B ]\r\n0x101e940                       0x101ebb0                       0x101ed50                       0x101ee40                       0x101efc0\r\n^                               ^                               ^                               ^                               ^\r\n[0x7ffec43881d0:0x7ffec43881d3] [0x7ffec43881e0:0x7ffec43881e7] [0x7ffec43881e8:0x7ffec43881ef] [0x7ffec43881f0:0x7ffec43881f7] [0x7ffec43881f8:0x7ffec43881ff]\r\n^                               ^                               ^                               ^                               ^\r\n0x101e900                       0x101eb70                       0x101ed10                       0x101ee00                       0x101ef80\r\n\r\n\r\n[ 56B ]                         [ 56B ]\r\n0x101e2f0                       0x101e490\r\n^                               ^\r\n[0x7ffec4388200:0x7ffec4388237] [0x7ffec4388238:0x7ffec438826f]\r\n^                               ^\r\n0x101e2b0                       0x101e450\r\n```\r\nAdding two more bytes with initial address 0x401a63 inserts the data between 2nd and 3rd element in the list:<br>\r\n```\r\n[ 8B ]              [ 8B ]              [ 2B ]              [ 6B ]              [ 6B ]              [ 4B ]              [ 56B ]\r\n0x101ec60           0x101e540           0x101eed0           0x101e6e0           0x101e3a0           0x101e850           0x101e630\r\n^                   ^                   ^                   ^                   ^                   ^                   ^\r\n[0x401a53:0x401a5a] [0x401a5b:0x401a62] [0x401a63:0x401a64] [0x401a65:0x401a6a] [0x401a6b:0x401a70] [0x6030f8:0x6030fb] [0x101e250:0x101e287] ...\r\n^                   ^                   ^                   ^                   ^                   ^                   ^\r\n0x101ec20           0x101e500           0x101ee90           0x101e6a0           0x101e360           0x101e810           0x101e5f0\r\n```\r\nInterval tree structure is implemented on top of the red-black trees (credits to the original Linux kernel developers from where this implementation has been taken). This also makes searching for the given interval a linearithmic operation.<br>\r\n\r\nThe final data structure used internally is so called fixup set. It's a standard set data structure build on top of red-black tree. Remember that parts of the memory image are linked together through pointers. We have 13 non-zero pointers in the working example above inside our 238B memory image, i.e.:<br>\r\n```c\r\ntype_arr[0].name\r\ntype_arr[0].next\r\ntype_arr[0].internal[0]\r\ntype_arr[0].internal[1]\r\ntype_arr[1].name\r\ntype_arr[1].next\r\nalloc_type->name\r\nalloc_type->next\r\nalloc_type->internal[0]\r\nalloc_type->internal[1]\r\nst[0]\r\nst[1]\r\nst[2]\r\n```\r\nDuring saving memory image we need to somehow mark all pointer locations which should be later fixed (new address should be recomputed) after deserialization. To facilitate that we store all pointer locations within memory image in the fixup set. Fixup set is represented by the `fixup_set_node` structure which defines the mapping (one element of a set) as follows:<br>\r\n```\r\n( {node:offset} => {node:offset} )\r\n```\r\nStandard memory pointers in most cases are represented by numbers (although C standard does not require that) which are addresses of some memory locations, i.e.\r\n```\r\ntype_arr[0].next : 0x7ffec4388210\r\n```\r\nFlatten memory representation is composed of the list of memory intervals. Therefore to represent the above pointer in flatten memory image we need to tell which interval holds the pointer storage at which offset within this interval. In the above case the `next` pointer is a part of `struct type` structure which is stored at interval:<br>\r\n```\r\n[ 56B ]\r\n0x101e2f0\r\n^\r\n[0x7ffec4388200:0x7ffec4388237]\r\n^\r\n0x101e2b0\r\n```\r\nThe address of this interval is 0x101e2b0, and `next` pointer is stored at offset 16 within this interval. All this leads to the following flatten pointer representation (`struct flatten_pointer` in the code) that points to the part of flatten memory:<br>\r\n```\r\n{0x101e2b0:16}\r\n```\r\nIn our case `next` field points to `type_arr[1]` structure which flatten pointer is:\r\n```\r\n{0x101e450:0}\r\n```\r\nFinally the mapping which is stored in fixup set (there is one mapping for each original pointer) has the form:<br>\r\n```\r\n( {0x101e2b0:16} => {0x101e450:0} )\r\n```\r\nFlatten pointers are inserted in fixup set by the function `fixup_set_insert`. Going back to our expanded code from the beginning of this section we have:\r\n```c\r\nif (_ptr->name) {\r\n    fixup_set_insert(__node, offsetof(struct type, name), flatten_plain_type(_ptr->name, strmemlen(_ptr->name)));\r\n}\r\n```\r\nHere we insert the mapping:<br>\r\n```\r\n( {__node:offsetof(struct type,name)} => (...) )\r\n```\r\nwith the value returned by the `flatten_plain_type()` function. In other words we might say:<br>\r\n\r\n\"There is a pointer in the `struct type` structure at offset 0 which points to a given memory interval at given offset (returned by the flattening function); remember that and later after deserialization assign proper address value to this pointer so it will point to the original flattened object.\"<br>\r\n\r\nRoot pointers does not have storage which is worked around using zeroed mapping:<br>\r\n```\r\n( {0:0} => (...) )\r\n```\r\nAnd code:<br>\r\n```c\r\nstruct flatten_pointer* __fptr = make_flatten_pointer(0, 0);\r\nif (root_ptr) {\r\n    fixup_set_insert(__fptr->node, __fptr->offset, flatten_struct_type((root_ptr)));\r\n}\r\n```\r\nZeroed mappings are not added to the fixup set (they are ignored by the `fixup_set_insert` function) as root pointers are handled differently (they are converted to the offset values from the beginnig of the image (position independent counterparts) file and stored additionally in the image header; check `struct root_addrnode` structure and its usage).<br>\r\n\r\nThe last remaining piece to explain is how libflat prepares all pointers within the image so only one simple fix is required after deserialization. It's already been explained how the memory fixing is done (<LINK>). When flattening phase is finished memory image is fully arranged of interval list with ascending order of original addresses. Next step is to compute the index at which each interval data begins (function `binary_stream_calculate_index`):<br>\r\n```\r\n{0}:[ 8B ]          {8}:[ 8B ]          {16}:[ 2B ]         {18}:[ 6B ]         {24}:[ 6B ]         {30}:[ 4B ]         {34}:[ 56B ]\r\n0x101ec60           0x101e540           0x101eed0           0x101e6e0           0x101e3a0           0x101e850           0x101e630\r\n^                   ^                   ^                   ^                   ^                   ^                   ^\r\n[0x401a53:0x401a5a] [0x401a5b:0x401a62] [0x401a63:0x401a64] [0x401a65:0x401a6a] [0x401a6b:0x401a70] [0x6030f8:0x6030fb] [0x101e250:0x101e287] ...\r\n^                   ^                   ^                   ^                   ^                   ^                   ^\r\n0x101ec20           0x101e500           0x101ee90           0x101e6a0           0x101e360           0x101e810           0x101e5f0\r\n\r\n\r\n{90}:[ 4B ]                     {94}:[ 8B ]                     {102}:[ 8B ]                    {110}:[ 8B ]                    {118}:[ 8B ]\r\n0x101e940                       0x101ebb0                       0x101ed50                       0x101ee40                       0x101efc0\r\n^                               ^                               ^                               ^                               ^\r\n[0x7ffec43881d0:0x7ffec43881d3] [0x7ffec43881e0:0x7ffec43881e7] [0x7ffec43881e8:0x7ffec43881ef] [0x7ffec43881f0:0x7ffec43881f7] [0x7ffec43881f8:0x7ffec43881ff]\r\n^                               ^                               ^                               ^                               ^\r\n0x101e900                       0x101eb70                       0x101ed10                       0x101ee00                       0x101ef80\r\n\r\n\r\n{126}:[ 56B ]                   {182}:[ 56B ]\r\n0x101e2f0                       0x101e490\r\n^                               ^\r\n[0x7ffec4388200:0x7ffec4388237] [0x7ffec4388238:0x7ffec438826f]\r\n^                               ^\r\n0x101e2b0                       0x101e450\r\n```\r\nNow when we look at the mapping in the fixup set:<br>\r\n```\r\n( {0x101e2b0:16} => {0x101e450:0} )\r\n```\r\nwe notice that the original pointer is located at offset 16 in the interval which data index is 126. This yields the final value 142. Furthermore this pointer points to interval which data index is 182 to the offset 0 (this gives the value 182). All what needs to be now done is to insert new position independent pointer value 182 at offset 142 if the flattened memory image (function `binary_stream_update_pointers`):<br>\r\n```\r\n[ | | | | ... | 182 | | | ...]\r\n^     ^       ^\r\n0     3       142\r\n```\r\nIt is worth to mention that we don't need to be worried about flattening NULL pointers, we just ignore them. NULL pointer has the value 0 which can be preserved between original and flattened memory image and will have the same meaning after deserialization.<br>\r\n\r\nFor debug purposes it is possible to dump all addresses of internal structures using the `flatten_debug_info()` function. To use the debugging functions include the following declarations into the source code as follows:<br>\r\n```\r\nvoid flatten_debug_info();\r\nvoid flatten_set_debug_flag(int flag);\r\n```\r\n##Limitations\r\n\r\nThere are several limitations to the current version of libflat which are listed below.<br>\r\n\r\n1. Libflat does not support serializing system elements. Examples might be `FILE` or `struct dirent` structures. Although it might be possible to write proper recipes for these structures and even flattening would be successfull. However these structures might hold values (like inode numbers, process IDs etc.) that have proper meaning only within the original process boundary. This is a hard limitation and seems impossible to resolve (unless there's anyone who doesn't yet know it's impossible) without adding additional code for restoring system elements after deserialization.<br>\r\n\r\n2. Current version of Libflat has limited support for flattening pointer to functions. Although it is possible to flatten the value a pointer to function points to but currently there is no possible to fix it during deserialization (there is no facility that would recognize pointers to functions and save proper fix information to be used later). It can be workaround by adding additional code after deserialization which resets pointer to functions to proper values in the new process context. However it can be burdensome (and in some cases even impossible, like original pointer to functions has been set according to the random program input). One idea is to use dynamic linker functionality, resolve function addresses within main binary or dynamically linked libraries and store resolved symbols. It would work for many cases (and therefore seems practical) however it would support only functions visible for the linker (i.e. support for static functions would be limited, but hey, who passes around static function addresses using pointer to functions? ;)).<br>\r\n\r\n3. After deserialization is done freeing or reallocating any pointer that was a part of memory image will invoke undefined behaviour (and very probable SIGSEGV signal or library assertion). This is due to the fact any allocated pointer in the original image is not allocated anymore after deserialization. There is only one allocation for the whole memory image that is about to be read in. Libflat provides two functions that can somehow mitigate this obstacle:<br>\r\n```c\r\nvoid* libflat_realloc (void* ptr, size_t size);\r\nvoid libflat_free (void* ptr);\r\n```\r\nThese two functions check whether the pointer that is freed/reallocated points inside flattened memory region and if this is the case free function does nothing and realloc returns new storage allocated using malloc of a given size (and copied memory content). In case of realloc we don't know how much storage was previously allocated therefore Libflat will try to copy all bytes given by the new size just to be sure (if new size exceeds the length of memory image then all bytes until end of memory image are copied). When the pointer that is freed/reallocated points outside of flattened memory normal standard free/realloc is used. Above two functions should be used instead of original free/realloc (e.g. by the preprocessor definition).<br>\r\n\r\nSolution described above yields another problem, i.e. the flattened memory content need to stay persistent in memory even though most of the content (accessible through pointers) might be deallocated and no longer used. Future solutions might track pointers frees/allocations and rebuild memory image when appropriate (that would need to somehow pass the information about the length of allocated storage though).<br>\r\n\r\n4. In the current version of Libflat there are some limitations for the structure and pointer overlays that can be flattened. For example structure storage can only be flattened as a whole memory block (any part of the structure flattened from other context will give assertion during structure processing). Same applies for the storage of pointers. Consider the below example:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nstruct type {\r\n    const char* name;\r\n    unsigned long v;\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(type,\r\n    AGGREGATE_FLATTEN_STRING(name);\r\n);\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    struct type s = {\"Some value here\", 0};\r\n\r\n    FOR_ROOT_POINTER((unsigned short*)&s.v,\r\n        FLATTEN_TYPE(unsigned short,(unsigned short*)&s.v);\r\n    );\r\n\r\n    FOR_ROOT_POINTER(&s,\r\n        FLATTEN_STRUCT(type, &s);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/8-in_a\r\n8-in_a: examples/8-in_a.c:12: flatten_struct_type: Assertion `__node->start==(uint64_t)_ptr' failed.\r\n```\r\n\r\nThis will fail as part of the structure storage (2 bytes of the `v` field) has already been flattened and structure can only be flattened as a whole.<br>\r\n\r\nSimilar thing happens for pointers:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    const char* st[2] = {\r\n            \"Some value here\",\r\n            \"Other value here\",\r\n    };\r\n\r\n    FOR_ROOT_POINTER((unsigned char*)&st[0],\r\n        FLATTEN_TYPE(unsigned char, (unsigned char*)&st[0]);\r\n    );\r\n\r\n    FOR_ROOT_POINTER(st,\r\n        FOREACH_POINTER(const char*, s, st, ptrarrmemlen((const void* const*)st),\r\n            FLATTEN_STRING(s);\r\n        );\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/8-in_b\r\n8-in_b: libflat.c:406: get_pointer_node: Assertion `node->last>=p+sizeof(void*)-1 && \"Invalid pointer address\"' failed.\r\n```\r\nHere 1 byte of the `st[0]` pointer has already been flattened and therefore flattening the whole pointer fails.<br>\r\n\r\nSuch situations (using part of structure/pointer storage in other contexts) are rare (and some might be considered bad practice) however they can happen (and sometimes there might be very good rationale to why to use them) therefore should be supported by Libflat seamlessly. There is actually no point why they wouldn't be supported (this derelict stems from initial library design and is no longer applicable) and will be supported in future releases of Libflat.<br>\r\n\r\n5. Libflat makes a copy of the original memory (i.e. bitwise copy) therefore flattening structures copies all the structure padding as well. This leads to the fact that after deserialization structure padding might be initialized differently as it would be if the structure had been initialized by compiler. This is reported by the Valgrind, however it's hard to imagine any other real-life consequences of this fact.<br>\r\n\r\n##Toubleshooting\r\n\r\nWhat to do when flattening fails? First thing to do is to check whether your use case falls into Libflat limitations (<LINK>). If not there are more possible scenarios that breaks the plateau.<br>\r\n\r\nConsider the following example:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nstruct internal_type {\r\n    int u:4;\r\n    char c;\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(internal_type);\r\n\r\nstruct type {\r\n    const char* name;\r\n    unsigned long v;\r\n    struct type* next;\r\n    struct internal_type* internal[4];\r\n};\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(type,\r\n    AGGREGATE_FLATTEN_STRING(name);\r\n    AGGREGATE_FLATTEN_STRUCT(type, next);\r\n    AGGREGATE_FLATTEN_TYPE_ARRAY(struct internal_type*, internal, 4);\r\n    FOREACH_POINTER(struct internal_type*, p, ATTR(internal), 4,\r\n        FLATTEN_STRUCT(internal_type, p);\r\n    );\r\n);\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    static struct internal_type u = { .u=1, .c='#' };\r\n\r\n    struct type type_arr = { .name=\"type1\", .v=666, &type_arr, {&u, &u, 0, 0}  };\r\n\r\n    FOR_ROOT_POINTER(&type_arr,\r\n        FLATTEN_STRUCT(type, &type_arr);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\nAfter running it you should get the following mysterious assertion:<br>\r\n```\r\n$ examples/8-in_c\r\n8-in_c: libflat.c:257: fixup_set_insert: Assertion `(inode->ptr->node->start+inode->ptr->offset)==(ptr->node->start+ptr->offset) && \"Multiple pointer mismatch for the same storage\"' failed.\r\n```\r\nThis tells us that we have just flattened some memory location through a pointer but previously we flattened different memory location through the same pointer (i.e. the same pointer points to two different locations at the same time). How it's possible? Take a look more closely at the flattening recipes:<br>\r\n```c\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(type,\r\n    AGGREGATE_FLATTEN_STRING(name);\r\n    AGGREGATE_FLATTEN_STRUCT(type, next);\r\n    AGGREGATE_FLATTEN_TYPE_ARRAY(struct internal_type*, internal, 4);\r\n    FOREACH_POINTER(struct internal_type*, p, ATTR(internal), 4,\r\n        FLATTEN_STRUCT(internal_type, p);\r\n    );\r\n);\r\n```\r\nHere we flatten whole structure `struct type` storage and its internal fields, i.e. `name, next, internal` pointer array and all the stuff the pointers from `internal` field points to. So where is the problem? It's actually quite difficult to grasp. The following line:<br>\r\n```c\r\nAGGREGATE_FLATTEN_TYPE_ARRAY(struct internal_type*, internal, 4);\r\n```\r\nflattens storage of 4 pointers from the `internal` array but it's already been flattened when the structure storage got dumped! In other words, the `internal` table is a part of structure storage (it is embedded inside the structure, pointer by pointer) and the above line is superfluous. To see the exact cause notice that `internal` expands to the type pointer to `struct internal*`, storage for our 4 pointers has already been flattened (when encompassing structure storage has been flattened) but Libflat remembers that at offset corresponding to `internal` field we have a pointer to the internal structure storage (this is incorrect!). Later on when we flatten first `struct internal_type` Libflat got another pointer at the same offset which points to different location (static frame where `u` has been defined). After removing the superfluous line all works as expected:<br>\r\n```c\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(type,\r\n    AGGREGATE_FLATTEN_STRING(name);\r\n    AGGREGATE_FLATTEN_STRUCT(type, next);\r\n    FOREACH_POINTER(struct internal_type*, p, ATTR(internal), 4,\r\n        FLATTEN_STRUCT(internal_type, p);\r\n    );\r\n);\r\n```\r\nAnother pitfall is to use root pointer which doesn't point to any location within flattened memory image:<br>\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n    FILE* out = fopen(\"/tmp/memory.img\", \"w\");\r\n    assert(out);\r\n    flatten_init();\r\n\r\n    const char* s = \"Very valuable data\";\r\n\r\n    FOR_ROOT_POINTER(&s,\r\n        FLATTEN_STRING(s);\r\n    );\r\n\r\n    assert(flatten_write(out) == 0);\r\n\r\n    flatten_fini();\r\n    fclose(out);\r\n\r\n    return 0;\r\n}\r\n```\r\n```\r\n$ examples/8-in_d\r\n8-in_d: libflat.c:530: flatten_write: Assertion `node!=0' failed.\r\n```\r\nHere the only actually flattened memory region is for the string storage area (19 bytes). Therefore root pointer which points to the address of first byte of the string is not included in the final memory image. To fix it replace flattening recipe by:<br>\r\n```c\r\nFOR_ROOT_POINTER(s,\r\n    FLATTEN_STRING(s);\r\n);\r\n```\r\nor include the pointer address in the flattened memory image:<br>\r\n```c\r\nFOR_ROOT_POINTER(&s,\r\n    FOR_POINTER(const char*, v, &s,\r\n        FLATTEN_STRING(v);\r\n    );\r\n);\r\n```\r\n##Contribution\r\n\r\nThere are number of ideas how to improve the Libflat. Some ideas are listed below.<br>\r\n\r\n1. Currently Libflat works on Linux and Windows (x86/x64 architecture). Port to ARM/ARM64 (Android) would be very appreciated.<br>\r\n2. All Libflat examples has been tested on Linux. It would be appreciated to prepare Visual Studio project and test all examples on Windows.<br>\r\n3. No tests has been done with C unions and adding such tests would be appreciated.<br>\r\n4. Fixing limited structure/pointer overlays (see limitations/4).<br>\r\n5. Adding root pointer to flattened memory image if not present (see troubleshooting).<br>\r\n6. Currently Libflat doesn't support flattening pointers to functions. This functionality would be implemented using dynamic linker capabilities (dladdr on Linux and Windows equivalent) by translating function addresses to corresponding symbols and storing it in the final memory image.<br>\r\n7. Currently Libflat API only allows to save entire memory image to single file. Consider enhancing the API to allow for creating and returning multiple flattened memory images for selected recipes.<br>\r\n8. Currently there is no support for C++ classes (only C++ POD types can be flattened). Design and implementation of flattening and reconstructing C++ classes would be appreciated (unfortunately it seems impossible to do this in C++ standard way and taking advantage of platform/compilator dependent functionalities would probably be needed).<br>\r\n9. Enable proper error handling instead of rough assertions.<br>\r\n10. Overcoming problems with free/reallocations in the unflattened memory image (see limitations/3).<br>\r\n11. More tests, error reports and bug fixes.<br>\r\n\r\n##Final word\r\n\r\nTo conclude all thoughts let's get back to the serializing GNU Make internal data structures. The question was whether we can omit the parsing phase at all and read in the whole memory content ready for going (or almost ready)? First version of Libflat was specifically created for that task. The main data structure of GNU Make internals is the `struct file` structure. It's opaque structure that branches and links with other `struct file` structues into the dependency graph. Other important structures are `struct hash_table` and `struct rule` among others.<br>\r\n\r\nThe following recipes has been created for the internal Make structures (three most complicated data structures has been selected here):<br>\r\n```c\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(file,\r\n    AGGREGATE_FLATTEN_STRING(name);\r\n    AGGREGATE_FLATTEN_STRING(hname);\r\n    AGGREGATE_FLATTEN_STRING(vpath);\r\n    AGGREGATE_FLATTEN_STRUCT(dep, deps);\r\n    AGGREGATE_FLATTEN_STRUCT(commands, cmds);\r\n    AGGREGATE_FLATTEN_STRING(stem);\r\n    AGGREGATE_FLATTEN_STRUCT(dep, also_make);\r\n    AGGREGATE_FLATTEN_STRUCT(file, prev);\r\n    AGGREGATE_FLATTEN_STRUCT(file, last);\r\n    AGGREGATE_FLATTEN_STRUCT(file, renamed);\r\n    AGGREGATE_FLATTEN_STRUCT(variable_set_list, variables);\r\n    AGGREGATE_FLATTEN_STRUCT(variable_set_list, pat_variables);\r\n    AGGREGATE_FLATTEN_STRUCT(file, parent);\r\n    AGGREGATE_FLATTEN_STRUCT(file, double_colon);\r\n);\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(hash_table,\r\n    AGGREGATE_FLATTEN_TYPE_ARRAY(void*, ht_vec, ATTR(ht_size));\r\n    FOREACH_POINTER(const void*, p, ATTR(ht_vec), ATTR(ht_size),\r\n        if (!HASH_VACANT (p)) FLATTEN_STRUCT(file, p);\r\n    );\r\n);\r\n\r\nFUNCTION_DEFINE_FLATTEN_STRUCT(rule,\r\n    AGGREGATE_FLATTEN_STRUCT(rule, next);\r\n    AGGREGATE_FLATTEN_TYPE_ARRAY(const char*, targets, ATTR(num));\r\n    FOREACH_POINTER(const char*, p, ATTR(targets), ATTR(num),\r\n        FLATTEN_STRING(p);\r\n    );\r\n    AGGREGATE_FLATTEN_TYPE_ARRAY(unsigned int, lens,ATTR(num));\r\n    AGGREGATE_FLATTEN_TYPE_ARRAY(const char*, suffixes, ATTR(num));\r\n    FOREACH_POINTER(const char*, p, ATTR(suffixes), ATTR(num),\r\n        FLATTEN_STRING(p);\r\n    );\r\n    AGGREGATE_FLATTEN_STRUCT(dep, deps);\r\n    AGGREGATE_FLATTEN_STRUCT(commands, cmds);\r\n);\r\n```\r\nAfter other amendments (pointer for functions for hash tables needed to be re-initialized among other things) internal GNU Make image has been created and saved:<br>\r\n```\r\n$ time make -M.cachefull\r\n============================================\r\nPLATFORM_VERSION_CODENAME=REL\r\nPLATFORM_VERSION=6.0\r\nTARGET_PRODUCT=aosp_arm64\r\nTARGET_BUILD_VARIANT=eng\r\nTARGET_BUILD_TYPE=release\r\nTARGET_BUILD_APPS=\r\nTARGET_ARCH=arm64\r\nTARGET_ARCH_VARIANT=armv8-a\r\nTARGET_CPU_VARIANT=generic\r\nTARGET_2ND_ARCH=arm\r\nTARGET_2ND_ARCH_VARIANT=armv7-a-neon\r\nTARGET_2ND_CPU_VARIANT=cortex-a15\r\nHOST_ARCH=x86_64\r\nHOST_OS=linux\r\nHOST_OS_EXTRA=Linux-3.13.0-58-generic-x86_64-with-Ubuntu-14.04-trusty\r\nHOST_BUILD_TYPE=release\r\nBUILD_ID=MRA58K\r\nOUT_DIR=out\r\n============================================\r\nincluding ./abi/cpp/Android.mk ...\r\nincluding ./art/Android.mk ...\r\nincluding ./bionic/Android.mk ...\r\n...\r\nincluding ./system/security/softkeymaster/Android.mk ...\r\nincluding ./system/vold/Android.mk ...\r\nincluding ./tools/external/fat32lib/Android.mk ...\r\n\r\n# Flattening done. Summary:\r\n  Memory size: 467750822 bytes\r\n  Linked 13075800 pointers\r\n  Written 572357358 bytes\r\n\r\nreal    1m26.891s\r\nuser    0m45.526s\r\nsys 0m39.327s\r\n```\r\nFinally reading-in internal GNU Make data structures with warm caches and fully built binaries (incremental build without changes) concludes the journey:<br>\r\n```\r\n$ time make -c.cachefull\r\n# Unflattening done. Summary:\r\n  Image read time: 0,101719s\r\n  Fixing memory time: 0,033349s\r\n  Total time: 0,135113s\r\n  Total bytes read: 572357358\r\nmake: Nothing to be done for 'droid'.\r\n\r\nreal    0m0.662s\r\nuser    0m0.465s\r\nsys 0m0.200s\r\n```\r\nstructures with warm caches and fully built binaries (incremental build without changes) concludes the journey:<br>\r\n```\r\n$ time make -c.cachefull\r\n# Unflattening done. Summary:\r\n  Image read time: 0,101719s\r\n  Fixing memory time: 0,033349s\r\n  Total time: 0,135113s\r\n  Total bytes read: 572357358\r\nmake: Nothing to be done for 'droid'.\r\n\r\nreal    0m0.662s\r\nuser    0m0.465s\r\nsys 0m0.200s\r\n```\r\n","google":"UA-73729732-1","note":"Don't delete this file! It's used internally to help with page regeneration."}