{"name":"Libflat","tagline":"Library for fast serialization of C/C++ structures","body":"## Overview\r\n\r\nLibflat is a library for fast serialization of C/C++ structures. Its main goal is speed (and of course correctness). Most of the time when you serialize your data the speed doesn't matter (in contrast to other factors like simplicity, good coverage etc.). But there are some cases when the speed is crucial, i.e. you're working with some big data sets and you need to serialize/deserialize them often (you might have some H/W device that produces a mass od data and you want to read in and process this data on another machine). <br>\r\n\r\nIn standard approach for serialization you pick up or design some protocol, choose low-level medium (like JSON) and write the logic to save your structures. On the other side of the mirror you read in the packets, figure out what they represent and combine them to recreate your beloved data. This is fine. Everybody do that. This works well. Unfortunately sometimes this works slow (rarely though and most of the times you can get away with it). Libflat is about to make this process as fast as possible by all cost. If you need this sort of speed standard you might want to check this out.<br>\r\n\r\nGood example for using Libflat is Android build system (still based on Makefile build system as of Feb. 2016). Android build system is monolithic which makes it extremely parallelizable. The main obstacle though is that you need to read all the makefiles up front (and there is lots of them). Trying it with hot caches gives the following (tests for android-6.0.0_r5)<br>\r\n```\r\n$ source build/envsetup.sh\r\n$ lunch aosp_arm64-eng\r\n$ time make\r\n============================================\r\nPLATFORM_VERSION_CODENAME=REL\r\nPLATFORM_VERSION=6.0\r\nTARGET_PRODUCT=aosp_arm64\r\nTARGET_BUILD_VARIANT=eng\r\nTARGET_BUILD_TYPE=release\r\nTARGET_BUILD_APPS=\r\nTARGET_ARCH=arm64\r\nTARGET_ARCH_VARIANT=armv8-a\r\nTARGET_CPU_VARIANT=generic\r\nTARGET_2ND_ARCH=arm\r\nTARGET_2ND_ARCH_VARIANT=armv7-a-neon\r\nTARGET_2ND_CPU_VARIANT=cortex-a15\r\nHOST_ARCH=x86_64\r\nHOST_OS=linux\r\nHOST_OS_EXTRA=Linux-3.13.0-58-generic-x86_64-with-Ubuntu-14.04-trusty\r\nHOST_BUILD_TYPE=release\r\nBUILD_ID=MRA58K\r\nOUT_DIR=out\r\n============================================\r\nincluding ./abi/cpp/Android.mk ...\r\nincluding ./art/Android.mk ...\r\nincluding ./bionic/Android.mk ...\r\n...\r\nincluding ./system/security/softkeymaster/Android.mk ...\r\nincluding ./system/vold/Android.mk ...\r\nincluding ./tools/external/fat32lib/Android.mk ...\r\n```\r\nSummary:\r\n```\r\n  real\t0m41.977s\r\n  user\t0m32.590s\r\n  sys\t0m9.654s\r\n```\r\nNot so bad, especially when you have a lots of RAM (so the only job that needs to be done is to parse all the Makefiles in memory using one thread). But what if we can omit the parsing phase at all and read in the whole memory content ready for going (or almost ready)?\r\n### How Libflat works\r\nLibflat works by making copy of the process memory for indicated variables and structures. It doesn't matter whether original storage is automatic, static or allocated. The result is always stored on the heap (and kept on the heap after deserialization).<br>\r\nMemory image is flat, i.e. whole copied memory image has continuous addresses. Pointers to original memory locations are properly resolved in the flattened image. Having whole memory serialized into one continuous memory block makes deserialization very fast (it is just a matter of reading entire block from disk to memory). Pointer resolution phase is needed after image is read in but this has linear complexity with number of pointers.<br>\r\n\r\nSimplest possible case of serialization can be made for automatic int variable as follows:\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n\tFILE* out = fopen(\"/tmp/memory.img\",\"w\");\r\n\tassert(out);\r\n\tflatten_init();\r\n\r\n\tint automatic = 0xDABBAD00;\r\n\r\n\tFOR_ROOT_POINTER(&automatic,\r\n\t\tFLATTEN_TYPE(int,&automatic);\r\n\t);\r\n\r\n\tassert(flatten_write(out)==0);\r\n\r\n\tflatten_fini();\r\n\tfclose(out);\r\n\r\n\treturn 0;\r\n}\r\n```\r\n```\r\n# Flattening done. Summary:\r\n  Memory size: 4 bytes\r\n  Linked 0 pointers\r\n  Written 44 bytes\r\n```\r\nOn the other side reading the stored value can be now done by:\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n\tFILE* in = fopen(\"/tmp/memory.img\",\"r\");\r\n\tassert(in);\r\n\tunflatten_init();\r\n\r\n\tassert(unflatten_read(in)==0);\r\n\r\n\tint* now_allocated = ROOT_POINTER_NEXT(int*);\r\n\tprintf(\"%08X\\n\",*now_allocated);\r\n\r\n\tunflatten_fini();\r\n\tfclose(in);\r\n\r\n\treturn 0;\r\n}\r\n```\r\n```\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000036s\r\n  Fixing memory time: 0.000000s\r\n  Total time: 0.000063s\r\n  Total bytes read: 44\r\n  DABBAD00\r\n```\r\nSimilar procedure can be done with arrays and strings as in the below examples:\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n\tFILE* out = fopen(\"/tmp/memory.img\",\"w\");\r\n\tassert(out);\r\n\tflatten_init();\r\n\r\n\tint i;\r\n\tconst char* s = \"Fibonacci would not calculate this as fast\";\r\n\tlong fib[40] = {0,1};\r\n\tfor (i=2; i<40; ++i) fib[i] = fib[i-1] + fib[i-2];\r\n\r\n\tFOR_ROOT_POINTER(fib,\r\n\t\tFLATTEN_TYPE_ARRAY(long,fib,40);\r\n\t);\r\n\r\n\tFOR_ROOT_POINTER(s,\r\n\t\tFLATTEN_STRING(s);\r\n\t);\r\n\r\n\tassert(flatten_write(out)==0);\r\n\r\n\tflatten_fini();\r\n\tfclose(out);\r\n\r\n\treturn 0;\r\n}\r\n```\r\n```\r\n# Flattening done. Summary:\r\n  Memory size: 363 bytes\r\n  Linked 0 pointers\r\n  Written 411 bytes\r\n```\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n\tFILE* in = fopen(\"/tmp/memory.img\",\"r\");\r\n\tassert(in);\r\n\tunflatten_init();\r\n\r\n\tassert(unflatten_read(in)==0);\r\n\r\n\tlong* fib = ROOT_POINTER_SEQ(long*,0);\r\n\tconst char* s = ROOT_POINTER_SEQ(const char*,1);\r\n\r\n\tint i;\r\n\tfor (i=0; i<40; ++i) printf(\"%ld \",fib[i]); printf(\"\\n\");\r\n\tprintf(\"%s\\n\",s);\r\n\r\n\tunflatten_fini();\r\n\tfclose(in);\r\n\r\n\treturn 0;\r\n}\r\n```\r\n```\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000055s\r\n  Fixing memory time: 0.000000s\r\n  Total time: 0.000100s\r\n  Total bytes read: 411\r\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597\r\n2584 4181 6765 10946 17711 28657 46368 75025 121393 196418\r\n317811 514229 832040 1346269 2178309 3524578 5702887 9227465\r\n14930352 24157817 39088169 63245986 \r\nFibonacci would not calculate this as fast\r\n```\r\nThis brings the notion of the so called root pointer. When you read the contents of memory you will have a block of data to your disposal. But how to access it? You need some pointer to any part of this memory (assuming you can interpret the memory from this point and link to other parts). This is what the root pointer is for. It is just a pointer to some part of unflatten memory. This has its own storage and is not part of the memory image (but of course it is part of the image file).<br>\r\n\r\nLet's back to our first example. \r\n```c\r\nint automatic = 0xDABBAD00;\r\n\r\nFOR_ROOT_POINTER(&automatic,\r\n\tFLATTEN_TYPE(int,&automatic);\r\n);\r\n```\r\nWe simply told our flattener engine that we want to access the memory through the address of the \"automatic\" variable (i.e. we will hold it reference). Check out that flattened memory size is 4 c-bytes (which happens to be the sizeof(int) on my example making machine). But it doesn't need to be this way. We can modify the first example slightly and specify the root pointer address through some other pointer variable:\r\n```c\r\nint automatic = 0xDABBAD00;\r\nint * pi = &automatic;\r\n\r\nFOR_ROOT_POINTER(pi,\r\n\tFLATTEN_TYPE(int,&automatic);\r\n);\r\n```\r\nAfter image read we just assign this value to our own defined variable as below:\r\n```c\r\nint* now_allocated = ROOT_POINTER_NEXT(int*);\r\n```\r\nYou might have several root pointers to several parts of unflatten memory. To access them you simply call `ROOT_POINTER_NEXT` with proper type sequentially to receive one root pointer after another (you will get them in the order you did issue `FOR_ROOT_POINTER` macro in the first place). You can also retrieve root pointers as below:\r\n```c\r\nconst char* s = ROOT_POINTER_SEQ(const char*,1);\r\n```\r\nThis will read the second (with index 1) root pointer stored while creating memory image.<br>\r\n\r\nAs you might have noticed in order to flatten some type you will need a pointer to it. But what about pointers (or pointers to pointers etc.)? There is no difference as long as you have a pointer to it (or pointer to pointer to it). Huh?\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n\tFILE* out = fopen(\"/tmp/memory.img\",\"w\");\r\n\tassert(out);\r\n\tflatten_init();\r\n\r\n\tdouble magic_number = 3.14159265359;\r\n\tdouble* pointer_to_it = &magic_number;\r\n\tdouble** pointer_to_pointer_to_it = &pointer_to_it;\r\n\tdouble*** ehhh = &pointer_to_pointer_to_it;\r\n\r\n\tFOR_ROOT_POINTER(ehhh,\r\n\t\tFLATTEN_TYPE(double**,&pointer_to_pointer_to_it);\r\n\t\tFOR_POINTER(double**,p,&pointer_to_pointer_to_it,\r\n\t\t\tFLATTEN_TYPE(double*,p);\r\n\t\t\tFOR_POINTER(double*,q,p,\r\n\t\t\t\tFLATTEN_TYPE(double,q);\r\n\t\t\t);\r\n\t\t);\r\n\t);\r\n\r\n\tassert(flatten_write(out)==0);\r\n\r\n\tflatten_fini();\r\n\tfclose(out);\r\n\r\n\treturn 0;\r\n}\r\n```\r\n```\r\n# Flattening done. Summary:\r\n  Memory size: 24 bytes\r\n  Linked 2 pointers\r\n  Written 80 bytes\r\n```\r\nYou have just written three values into memory (two pointers and one double value). How so?<br>\r\n\r\nThe line:\r\n```c\r\nFLATTEN_TYPE(double**,&pointer_to_pointer_to_it);\r\n```\r\nwrites the value pointed to by `&pointer_to_pointer_to_it` which is of type double** (this is the actual value stored in the `pointer_to_pointer_to_it` pointer). We did exactly the same in the first example:\r\n```c\r\nFLATTEN_TYPE(int,&automatic);\r\n```\r\nWe wrote the value pointed to by `&automatic` which was of type int.<br>\r\n\r\nNext line:\r\n```c\r\nFOR_POINTER(double**,p,&pointer_to_pointer_to_it,...);\r\n```\r\ntakes the actual value pointed to by `&pointer_to_pointer_to_it` and stores it in newly created variable `p` of appropriate type (double**). This variable must be pointer hence the macro name. New variable `p` (you can actually give it any accessible name) can be used in the block of code that follows (\"...\" macro arguments).<br>\r\n\r\nThe following code we does the same trick, i.e. writes the value pointed by `p` (of type double*):\r\n```c\r\nFLATTEN_TYPE(double*,p);\r\n```\r\nFinally we create another variable `q` that acquires the value pointed by `p` (which finally points to the magic double value) and writes the double number to the memory image:\r\n```c\r\nFOR_POINTER(double*,q,p,\r\n\tFLATTEN_TYPE(double,q);\r\n);\r\n```\r\nChecking the stored value confirms our words:\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n\tFILE* in = fopen(\"/tmp/memory.img\",\"r\");\r\n\tassert(in);\r\n\tunflatten_init();\r\n\r\n\tassert(unflatten_read(in)==0);\r\n\r\n\tdouble*** ehhh = ROOT_POINTER_SEQ(double***,0);\r\n\tprintf(\"The magic answer to the ultimate question of life?: %f\\n\",***ehhh);\r\n\r\n\tunflatten_fini();\r\n\tfclose(in);\r\n\r\n\treturn 0;\r\n}\r\n```\r\n```\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000058s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000105s\r\n  Total bytes read: 80\r\nThe magic answer to the ultimate question of life?: 3.141593\r\n```\r\nIn the write output you can now see the line that says:\r\n`Linked 2 pointers`\r\nThe memory image contained two pointers as we just explained. But after reading them in in the second process (which could actually happened on different computer on diffrenent continent) the pointer values would not probably have any proper meaning in the context of new process address space. That's why we need to fix them.<br>\r\n\r\nConsider the following block of code:\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n\tFILE* out = fopen(\"/tmp/memory.img\",\"w\");\r\n\tassert(out);\r\n\tflatten_init();\r\n\r\n\tstatic char carr[] = \"You don't need to be great to start, but you need to start to be great\";\r\n\r\n\tconst char* start = carr;\r\n\tconst char* middle = carr+41;\r\n\r\n\tFOR_ROOT_POINTER(start,\r\n\t\tFLATTEN_TYPE(const char*,&start);\r\n\t\tFOR_POINTER(const char*,s,&start,\r\n\t\t\tFLATTEN_STRING(s);\r\n\t\t);\r\n\t);\r\n\r\n\tFOR_ROOT_POINTER(middle,\r\n\t\tFLATTEN_TYPE(const char*,&middle);\r\n\t\tFOR_POINTER(const char*,s,&middle,\r\n\t\t\tFLATTEN_STRING(s);\r\n\t\t);\r\n\t);\r\n\r\n\tprintf(\"&carr[0]: %p\\n\",&carr[0]);\r\n\tprintf(\"&start: %p -> %p\\n\",&start,start);\r\n\tprintf(\"&middle: %p -> %p\\n\",&middle,middle);\r\n\r\n\tassert(flatten_write(out)==0);\r\n\r\n\tflatten_fini();\r\n\tfclose(out);\r\n\r\n\treturn 0;\r\n}\r\n```\r\nAnd the result of running it:\r\n```\r\n  &carr[0]: 0x6020c0\r\n  &start: 0x7fff9da3a8c0 -> 0x6020c0\r\n  &middle: 0x7fff9da3a8c8 -> 0x6020e9\r\n    # Flattening done. Summary:\r\n    Memory size: 87 bytes\r\n    Linked 2 pointers\r\n    Written 151 bytes\r\n```\r\nThe original memory looks as follows:\r\n```\r\nSomewhere in the static memory area:\r\n0x6020c0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0]\r\n\t\t\t\t\t\t\t\t ^\r\n\t\t\t\t\t\t\t\t 0x6020e9\r\nSomewhere on the stack:\r\n0x7fff9da3a8c0: [0x6020c0|0x6020e9]\r\n````\r\nLibflat will arrange memory image in ascending order of original addresses:\r\n````\r\n[Y|o|u|...|g|r|e|a|t|0|0x6020c0|0x6020e9]\r\n```\r\nand replace original pointer values with its position independent counterparts (independent from the starting address of the memory image in the process address space):\r\n```\r\n[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029]\r\n ^\t\t\t\t\t   ^\r\n 0x000000\t\t\t   0x000029\r\n```\r\nIt also needs to store two additional values, i.e. at which offset in the flattened memory area actual pointers appears (as we need to find them later):\r\n```\r\n[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f]\r\n \t\t\t\t\t\t\t\t\t\t\t ^\t   \t  ^\r\n \t\t\t\t\t\t\t\t\t\t\t 0x47\t  0x4f\r\n```\r\nFinally it also stores two root pointers (start and middle pointer values) as the offsets in the flattened memory image for later retrieval:\r\n```\r\n[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f] [0x47,0x4f]\r\n\t\t\t\t\t ^\t  ^\r\n\t\t\t\t\t start offset\r\n\t\t\t\t\t\t ^\r\n\t\t\t\t\t middle offset\r\n```\r\nIn this example we have only two pointers and both of them are root pointers therefore stored values are duplicated. In real life scenarios we will probably have much more standard pointers and very few root pointers (as all must be manually setup by programmer).<br>\r\nDuring unflattening stage (as in the below example) several things happen.\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n\tFILE* in = fopen(\"/tmp/memory.img\",\"r\");\r\n\tassert(in);\r\n\tunflatten_init();\r\n\r\n\tassert(unflatten_read(in)==0);\r\n\r\n\tconst char* start = ROOT_POINTER_SEQ(const char*,0);\r\n\tconst char* middle = ROOT_POINTER_SEQ(const char*,1);\r\n\r\n\tprintf(\"&start: %p -> %p\\n\",&start,start);\r\n\tprintf(\"&middle: %p -> %p\\n\",&middle,middle);\r\n\tconst void* ptr1 = start+strlen(start)+1;\r\n\tprintf(\"*(%p) => %p\\n\",ptr1,*(void**)ptr1);\r\n\tconst void* ptr2 = start+strlen(start)+1+sizeof(const char*);\r\n\tprintf(\"*(%p) => %p\\n\",ptr2,*(void**)ptr2);\r\n\tprintf(\"%s\\n\",start);\r\n\tprintf(\"Remember: %s\\n\",middle);\r\n\r\n\tunflatten_fini();\r\n\tfclose(in);\r\n\r\n\treturn 0;\r\n}\r\n```\r\n```\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000037s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000068s\r\n  Total bytes read: 151\r\n&start: 0x7ffe7454eae0 -> 0x8de2a0\r\n&middle: 0x7ffe7454eae8 -> 0x8de2c9\r\n*(0x8de2e7) => 0x8de2a0\r\n*(0x8de2ef) => 0x8de2c9\r\nYou don't need to be great to start, but you need to start to be great\r\nRemember: you need to start to be great\r\n```\r\nNew memory area is created in the allocated storage area (the heap) and memory image is read in:\r\n```\r\n0x8de2a0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f] [0x47,0x4f]\r\n\t\t\t\t\t\t\t\t ^\r\n\t\t\t\t\t\t\t\t 0x8de2c9\r\n```\r\nNow we read two pointer offsets (0x47 and 0x4f) and fix two pointers at these offsets by adding the initial address of the allocated memory area to the position independent pointer value:\r\n```\r\n0x8de2a0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x8de2a0|0x8de2c9] [0x47,0x4f] [0x47,0x4f]\r\n\t\t\t\t\t\t\t\t ^\t\t\t\t\t   ^\t\t^\t\t  ^ pointer offset array\r\n\t\t\t\t\t\t\t\t 0x8de2c9\t\t\t   0x47\t\t0x4f\t\t\t\t   ^\r\n\t\t\t\t\t\t\t\t \t\t\t\t\t   ^\t\t^\t\t\t\t\t   root pointer offset array\r\n\t\t\t\t\t\t\t\t \t\t\t\t\t   0x8de2e7 0x8de2ef\r\n```\r\nNow the first pointer points at the beginning of the string and second points in the middle. This process is called linking and this is what the line \"Linked 2 pointers\" was talking about.<br>\r\nFinally we read two root pointers at offset location 0x47 and 0x4f which happens to be the same values as the only two pointers, create their storage and set the translated values:\r\n```\r\n&start: 0x7ffe7454eae0 -> 0x8de2a0\r\n&middle: 0x7ffe7454eae8 -> 0x8de2c9\r\n```\r\nTo finally confirm the example we will move start pointer (and the second pointer) by the length of the string and read the value stored at the resulting location:\r\n```c\r\nconst void* ptr1 = start+strlen(start)+1;\r\nprintf(\"*(%p) => %p\\n\",ptr1,*(void**)ptr1);\r\nconst void* ptr2 = start+strlen(start)+1+sizeof(const char*);\r\nprintf(\"*(%p) => %p\\n\",ptr2,*(void**)ptr2);\r\n```\r\n```\r\n*(0x8de2e7) => 0x8de2a0\r\n*(0x8de2ef) => 0x8de2c9\r\n```\r\nThere is actually more you can do with pointers. For instance you can manage arrays of pointers in similar fashion:\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n\tFILE* out = fopen(\"/tmp/memory.img\",\"w\");\r\n\tassert(out);\r\n\tflatten_init();\r\n\r\n\tconst char* argv[] = {\r\n\t\t\t\"Program name\",\r\n\t\t\t\"Argument 0\",\r\n\t\t\t\"Argument 1\",\r\n\t\t\t\"Argument 2\",\r\n\t\t\t\"Argument 3\",\r\n\t\t\t0\r\n\t};\r\n\r\n\tFOR_ROOT_POINTER(argv,\r\n\t\tFOREACH_POINTER(const char*,arg,argv,ptrarrmemlen((const void * const*)argv),\r\n\t\t\tFLATTEN_TYPE(const char*,arg);\r\n\t\t\tFLATTEN_STRING(arg);\r\n\t\t);\r\n\t);\r\n\r\n\tassert(flatten_write(out)==0);\r\n\r\n\tflatten_fini();\r\n\tfclose(out);\r\n\r\n\treturn 0;\r\n}\r\n```\r\n```\r\n# Flattening done. Summary:\r\n  Memory size: 105 bytes\r\n  Linked 5 pointers\r\n  Written 185 bytes\r\n```\r\nHere, for each pointer in the array `argv` we create temporary variable `arg` of type `const char*` which we can use in the subsequent block of code. We must specify the size of the array. We might know it in advance or we can compute it in real time. In case of arrays terminated with pointer 0 (NULL pointer) there is function `ptrarrmemlen` available for this purpose. It simply iterates through entire pointer array and counts the pointers until it reaches the pointer 0 (and counts it as well). Similar function is used internally by the `FLATTEN_STRING` macro, i.e. `strmemlen` function which returns the length of string including NULL terminating 0 value.<br>\r\n\r\nIn the code body we first flatten the pointer itself and then we flatten the string pointed to by it.\r\n```c\r\n#include <stdio.h>\r\n#include <assert.h>\r\n#include <stdint.h>\r\n#include \"libflat.h\"\r\n\r\nint main(void) {\r\n\r\n\tFILE* in = fopen(\"/tmp/memory.img\",\"r\");\r\n\tassert(in);\r\n\tunflatten_init();\r\n\r\n\tassert(unflatten_read(in)==0);\r\n\r\n\tconst char** argv = ROOT_POINTER_NEXT(const char**);\r\n\twhile(*argv) {\r\n\t\tprintf(\"%s\\n\",*argv);\r\n\t\targv++;\r\n\t}\r\n\r\n\tunflatten_fini();\r\n\tfclose(in);\r\n\r\n\treturn 0;\r\n}\r\n```\r\n```\r\n# Unflattening done. Summary:\r\n  Image read time: 0.000057s\r\n  Fixing memory time: 0.000001s\r\n  Total time: 0.000104s\r\n  Total bytes read: 185\r\nProgram name\r\nArgument 0\r\nArgument 1\r\nArgument 2\r\nArgument 3\r\n```\r\n","google":"UA-73729732-1","note":"Don't delete this file! It's used internally to help with page regeneration."}