<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Libflat by braton</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Libflat</h1>
      <h2 class="project-tagline">Library for fast serialization of C structures</h2>
      <a href="https://github.com/braton/libflat" class="btn">View on GitHub</a>
      <a href="https://github.com/braton/libflat/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/braton/libflat/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h2>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h2>

<p>Libflat is a library for fast serialization of C structures. Its main goal is speed (and of course correctness). Most of the time when you serialize your data the speed doesn't really matter (in contrast to other factors like simplicity, good coverage etc.). But there are cases when the speed is crucial, i.e. you're working with some big data sets and you need to serialize/deserialize them often (you might have some H/W device that produces a mass of data for further processing and you want to read in and analyze this data on another machine).<br></p>

<p>In standard approach for serialization you pick up or design some protocol (e.g. based on JSON) and write the logic to save your structures. On the other side of the mirror you read in the packets, figure out what they represent and combine them to recreate your beloved data. This is fine. This works well. Unfortunately sometimes this works rather slow (rarely though and most of the time you can get away with it). Libflat is about to make this process as fast as possible by all cost.<br></p>

<p>Good example for using Libflat is Android build system (still based on Makefile build system as of Feb. 2016). Androd build system is monolithic which makes it extremely parallelizable.<br>
The main obstacle though (especially when you need to do lots of partial builds) is that you need to read all the makefiles up front (and there is lots of them). Trying it with hot caches gives the following (tests for android-6.0.0_r5)<br></p>

<pre><code>$ source build/envsetup.sh
$ lunch aosp_arm64-eng
$ time make
============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=6.0
TARGET_PRODUCT=aosp_arm64
TARGET_BUILD_VARIANT=eng
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm64
TARGET_ARCH_VARIANT=armv8-a
TARGET_CPU_VARIANT=generic
TARGET_2ND_ARCH=arm
TARGET_2ND_ARCH_VARIANT=armv7-a-neon
TARGET_2ND_CPU_VARIANT=cortex-a15
HOST_ARCH=x86_64
HOST_OS=linux
HOST_OS_EXTRA=Linux-3.13.0-58-generic-x86_64-with-Ubuntu-14.04-trusty
HOST_BUILD_TYPE=release
BUILD_ID=MRA58K
OUT_DIR=out
============================================
including ./abi/cpp/Android.mk ...
including ./art/Android.mk ...
including ./bionic/Android.mk ...
...
including ./system/security/softkeymaster/Android.mk ...
including ./system/vold/Android.mk ...
including ./tools/external/fat32lib/Android.mk ...
</code></pre>

<p>Summary:<br></p>

<pre><code>real    0m41.977s
user    0m32.590s
sys     0m9.654s
</code></pre>

<p>Not so bad, especially when you have lots of RAM (so the only job that needs to be done is to parse all the Makefiles in memory using one thread). But what if we can omit the parsing phase at all and read in the whole memory content ready for going (or almost ready)?<br></p>

<h2>
<a id="how-libflat-works" class="anchor" href="#how-libflat-works" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How Libflat works</h2>

<p>Libflat works by making copy of the process memory for indicated variables and structures. It doesn't matter whether original storage is automatic, static or allocated. The result is always stored on the heap (and kept on the heap after deserialization). Memory image is flat, i.e. whole copied memory image has continuous addresses. Pointers to original memory locations are properly resolved in the flattened image. Having whole memory serialized into one continuous memory block makes deserialization very fast (it is just a matter of reading entire block from disk to memory). Pointer resolution phase is needed after image is read in but this has linear complexity with number of pointers.<br></p>

<p>Simplest possible case of serialization can be made for automatic int variable as follows:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">int</span> automatic = 0xDABBAD00;

    <span class="pl-c1">FOR_ROOT_POINTER</span>(&amp;automatic,
        <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">int</span>, &amp;automatic);
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/1-in
# Flattening done. Summary:
  Memory size: 4 bytes
  Linked 0 pointers
  Written 44 bytes
</code></pre>

<p>On the other side reading the stored value can be now done by:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* in = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(in);
    <span class="pl-c1">unflatten_init</span>();

    <span class="pl-c1">assert</span>(<span class="pl-c1">unflatten_read</span>(in) == <span class="pl-c1">0</span>);

    <span class="pl-k">int</span>* now_allocated = <span class="pl-c1">ROOT_POINTER_NEXT</span>(<span class="pl-k">int</span>*);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%08X</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, *now_allocated);

    <span class="pl-c1">unflatten_fini</span>();
    <span class="pl-c1">fclose</span>(in);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/1-out
# Unflattening done. Summary:
  Image read time: 0.000036s
  Fixing memory time: 0.000000s
  Total time: 0.000063s
  Total bytes read: 44
DABBAD00
</code></pre>

<p>Similar procedure can be done with arrays and strings as in the below examples:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdint.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">int</span> i;
    <span class="pl-k">const</span> <span class="pl-k">char</span>* s = <span class="pl-s"><span class="pl-pds">"</span>Fibonacci would not calculate this as fast<span class="pl-pds">"</span></span>;
    <span class="pl-k">long</span> fib[<span class="pl-c1">40</span>] = { <span class="pl-c1">0</span>, <span class="pl-c1">1</span> };
    <span class="pl-k">for</span> (i = <span class="pl-c1">2</span>; i &lt; <span class="pl-c1">40</span>; ++i)
        fib[i] = fib[i - <span class="pl-c1">1</span>] + fib[i - <span class="pl-c1">2</span>];

    <span class="pl-c1">FOR_ROOT_POINTER</span>(fib,
        <span class="pl-c1">FLATTEN_TYPE_ARRAY</span>(<span class="pl-k">long</span>, fib, <span class="pl-c1">40</span>);
    );

    <span class="pl-c1">FOR_ROOT_POINTER</span>(s,
        <span class="pl-c1">FLATTEN_STRING</span>(s);
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/2-in
# Flattening done. Summary:
  Memory size: 363 bytes
  Linked 0 pointers
  Written 411 bytes
</code></pre>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdint.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* in = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(in);
    <span class="pl-c1">unflatten_init</span>();

    <span class="pl-c1">assert</span>(<span class="pl-c1">unflatten_read</span>(in) == <span class="pl-c1">0</span>);

    <span class="pl-k">long</span>* fib = <span class="pl-c1">ROOT_POINTER_SEQ</span>(<span class="pl-k">long</span>*, <span class="pl-c1">0</span>);
    <span class="pl-k">const</span> <span class="pl-k">char</span>* s = <span class="pl-c1">ROOT_POINTER_SEQ</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, <span class="pl-c1">1</span>);

    <span class="pl-k">int</span> i;
    <span class="pl-k">for</span> (i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">40</span>; ++i)
        <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%ld</span> <span class="pl-pds">"</span></span>, fib[i]);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%s</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, s);

    <span class="pl-c1">unflatten_fini</span>();
    <span class="pl-c1">fclose</span>(in);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/2-out
# Unflattening done. Summary:
  Image read time: 0.000055s
  Fixing memory time: 0.000000s
  Total time: 0.000100s
  Total bytes read: 411
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 
Fibonacci would not calculate this as fast
</code></pre>

<p>This brings the notion of the so called root pointer. When you read the contents of memory you will have a block of data to your disposal. But how to access it? You need some pointer to any part of this memory (assuming you can interpret the memory from this point and link to other parts). This is what the root pointer is for. It is just a pointer to some part of unflatten memory. This has its own storage and is not part of the memory image (but of course it is part of the image file).<br>
Let's back to our first example. <br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> automatic = 0xDABBAD00;

<span class="pl-en">FOR_ROOT_POINTER</span>(&amp;automatic,
    <span class="pl-en">FLATTEN_TYPE</span>(<span class="pl-k">int</span>, &amp;automatic);
);</pre></div>

<p>We simply told our flattener engine that we want to access the memory through the address of the <code>automatic</code> variable (i.e. we will hold it reference). Check out that flattened memory size is 4 c-bytes (which happens to be the sizeof(int) on my example making machine). But it doesn't need to be this way. We can modify the first example slightly and specify the root pointer address through some other pointer variable:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> automatic = 0xDABBAD00;
<span class="pl-k">int</span>* pi = &amp;automatic;

<span class="pl-en">FOR_ROOT_POINTER</span>(pi,
    <span class="pl-en">FLATTEN_TYPE</span>(<span class="pl-k">int</span>, &amp;automatic);
);</pre></div>

<p>After image read we just assign this value to our own defined variable as below:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">int</span>* now_allocated = ROOT_POINTER_NEXT(<span class="pl-k">int</span>*);</pre></div>

<p>You might have several root pointers to several parts of unflatten memory. To access them you simply call <code>ROOT_POINTER_NEXT</code> with proper type sequentially to receive one root pointer after another (you will get them in the order you did issue <code>FOR_ROOT_POINTER</code> macro in the first place). You can also retrieve root pointers as below:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">const</span> <span class="pl-k">char</span>* s = ROOT_POINTER_SEQ(<span class="pl-k">const</span> <span class="pl-k">char</span>*, <span class="pl-c1">1</span>);</pre></div>

<p>This will read the second (with index 1) root pointer stored while creating memory image.<br></p>

<p>As you might have noticed in order to flatten some type you will need a pointer to it. But what about pointers (or pointers to pointers etc.)? There is no difference as long as you have a pointer to it (or pointer to pointer to it). Huh?<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">double</span> magic_number = <span class="pl-c1">3.14159265359</span>;
    <span class="pl-k">double</span>* pointer_to_it = &amp;magic_number;
    <span class="pl-k">double</span>** pointer_to_pointer_to_it = &amp;pointer_to_it;
    <span class="pl-k">double</span>*** ehhh = &amp;pointer_to_pointer_to_it;

    <span class="pl-c1">FOR_ROOT_POINTER</span>(ehhh,
        <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">double</span>**, &amp;pointer_to_pointer_to_it);
        <span class="pl-c1">FOR_POINTER</span>(<span class="pl-k">double</span>**,p, &amp;pointer_to_pointer_to_it,
            <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">double</span>*, p);
            <span class="pl-c1">FOR_POINTER</span>(<span class="pl-k">double</span>*, q, p,
                <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">double</span>, q);
            );
        );
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/3-in
# Flattening done. Summary:
  Memory size: 24 bytes
  Linked 2 pointers
  Written 80 bytes
</code></pre>

<p>You have just written three values into memory (two pointers and one double value). How so?<br></p>

<p>The line:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FLATTEN_TYPE</span>(<span class="pl-k">double</span>**, &amp;pointer_to_pointer_to_it);</pre></div>

<p>writes the value pointed to by <code>&amp;pointer_to_pointer_to_it</code> which is of type double** (this is the actual value stored in the <code>pointer_to_pointer_to_it</code> pointer). We did exactly the same in the first example:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FLATTEN_TYPE</span>(<span class="pl-k">int</span>, &amp;automatic);</pre></div>

<p>We wrote the value pointed to by <code>&amp;automatic</code> which was of type int.<br></p>

<p>Next line:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FOR_POINTER</span>(<span class="pl-k">double</span>**, p, &amp;pointer_to_pointer_to_it,...);</pre></div>

<p>takes the actual value pointed to by <code>&amp;pointer_to_pointer_to_it</code> and stores it in newly created variable <code>p</code> of appropriate type (double**). This variable must be pointer hence the macro name. New variable <code>p</code> (you can actually give it any accessible name) can be used in the block of code that follows (<code>...</code> macro arguments).<br></p>

<p>The following code we does the same trick, i.e. writes the value pointed by <code>p</code> (of type double*):<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FLATTEN_TYPE</span>(<span class="pl-k">double</span>*, p);</pre></div>

<p>Finally we create another variable <code>q</code> that acquires the value pointed by <code>p</code> (which finally points to the magic double value) and writes the double number to the memory image:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FOR_POINTER</span>(<span class="pl-k">double</span>*, q, p,
    <span class="pl-en">FLATTEN_TYPE</span>(<span class="pl-k">double</span>, q);
);</pre></div>

<p>Checking the stored value confirms our words:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdint.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* in = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(in);
    <span class="pl-c1">unflatten_init</span>();

    <span class="pl-c1">assert</span>(<span class="pl-c1">unflatten_read</span>(in) == <span class="pl-c1">0</span>);

    <span class="pl-k">double</span>*** ehhh = <span class="pl-c1">ROOT_POINTER_SEQ</span>(<span class="pl-k">double</span>***, <span class="pl-c1">0</span>);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>The magic answer to the ultimate question of life?: <span class="pl-c1">%f</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, ***ehhh);

    <span class="pl-c1">unflatten_fini</span>();
    <span class="pl-c1">fclose</span>(in);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/3-out
# Unflattening done. Summary:
  Image read time: 0.000058s
  Fixing memory time: 0.000001s
  Total time: 0.000105s
  Total bytes read: 80
The magic answer to the ultimate question of life?: 3.141593
</code></pre>

<p>In the write output you can now see the line that says:<br></p>

<pre><code>Linked 2 pointers
</code></pre>

<p>The memory image contained two pointers as we just explained. But after reading them in in the second process (which could actually happened on different computer on diffrenent continent) the pointer values would not probably have any proper meaning in the context of new process address space. That's why we need to fix them.<br></p>

<p>Consider the following block of code:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">static</span> <span class="pl-k">char</span> carr[] = <span class="pl-s"><span class="pl-pds">"</span>You don't need to be great to start, <span class="pl-pds">"</span></span>
            <span class="pl-s"><span class="pl-pds">"</span>but you need to start to be great<span class="pl-pds">"</span></span>;

    <span class="pl-k">const</span> <span class="pl-k">char</span>* start = carr;
    <span class="pl-k">const</span> <span class="pl-k">char</span>* middle = carr + <span class="pl-c1">41</span>;

    <span class="pl-c1">FOR_ROOT_POINTER</span>(start,
        <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, &amp;start);
        <span class="pl-c1">FOR_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, s, &amp;start,
            <span class="pl-c1">FLATTEN_STRING</span>(s);
        );
    );

    <span class="pl-c1">FOR_ROOT_POINTER</span>(middle,
        <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, &amp;middle);
        <span class="pl-c1">FOR_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, s, &amp;middle,
            <span class="pl-c1">FLATTEN_STRING</span>(s);
        );
    );

    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>&amp;carr[0]: <span class="pl-c1">%p</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, &amp;carr[<span class="pl-c1">0</span>]);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>&amp;start: <span class="pl-c1">%p</span> -&gt; <span class="pl-c1">%p</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, &amp;start, start);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>&amp;middle: <span class="pl-c1">%p</span> -&gt; <span class="pl-c1">%p</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, &amp;middle, middle);

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<p>And the result of running it:<br></p>

<pre><code>$ examples/4-in
&amp;carr[0]: 0x6020c0
&amp;start: 0x7fff9da3a8c0 -&gt; 0x6020c0
&amp;middle: 0x7fff9da3a8c8 -&gt; 0x6020e9
# Flattening done. Summary:
  Memory size: 87 bytes
  Linked 2 pointers
  Written 151 bytes
</code></pre>

<p>The original memory looks as follows:<br></p>

<p>Somewhere in the static memory area:<br></p>

<pre><code>0x6020c0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0]
                                 ^
                                 0x6020e9
</code></pre>

<p>Somewhere on the stack:<br></p>

<pre><code>0x7fff9da3a8c0: [0x6020c0|0x6020e9]
</code></pre>

<p>Libflat will arrange memory image in ascending order of original addresses:<br></p>

<pre><code>[Y|o|u|...|g|r|e|a|t|0|0x6020c0|0x6020e9]
</code></pre>

<p>and replace original pointer values with its position independent counterparts (independent from the starting address of the memory image in the process address space):<br></p>

<pre><code>[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029]
 ^                     ^
 0x000000              0x000029
</code></pre>

<p>It also needs to store two additional values, i.e. at which offset in the flattened memory area actual pointers appears (as we need to find them later):<br></p>

<pre><code>[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f]
                                             ^        ^
                                             0x47     0x4f
</code></pre>

<p>Finally it also stores two root pointers (start and middle pointer values) as the offsets in the flattened memory image for later retrieval:<br></p>

<pre><code>[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f] [0x47,0x4f]
                                                                             ^    ^
                                                                             start offset
                                                                                  ^
                                                                                  middle offset
</code></pre>

<p>In this example we have only two pointers and both of them are root pointers therefore stored values are duplicated. In real life scenarios we will probably have much more standard pointers and very few root pointers (as all must be manually setup by programmer).<br></p>

<p>During unflattening stage (as in the below example) several things happen.<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdint.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* in = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(in);
    <span class="pl-c1">unflatten_init</span>();

    <span class="pl-c1">assert</span>(<span class="pl-c1">unflatten_read</span>(in) == <span class="pl-c1">0</span>);

    <span class="pl-k">const</span> <span class="pl-k">char</span>* start = <span class="pl-c1">ROOT_POINTER_SEQ</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, <span class="pl-c1">0</span>);
    <span class="pl-k">const</span> <span class="pl-k">char</span>* middle = <span class="pl-c1">ROOT_POINTER_SEQ</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, <span class="pl-c1">1</span>);

    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>&amp;start: <span class="pl-c1">%p</span> -&gt; <span class="pl-c1">%p</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, &amp;start, start);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>&amp;middle: <span class="pl-c1">%p</span> -&gt; <span class="pl-c1">%p</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, &amp;middle, middle);
    <span class="pl-k">const</span> <span class="pl-k">void</span>* ptr1 = start + <span class="pl-c1">strlen</span>(start) + <span class="pl-c1">1</span>;
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>*(<span class="pl-c1">%p</span>) =&gt; <span class="pl-c1">%p</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, ptr1, *(<span class="pl-k">void</span>**) ptr1);
    <span class="pl-k">const</span> <span class="pl-k">void</span>* ptr2 = start + <span class="pl-c1">strlen</span>(start) + <span class="pl-c1">1</span> + <span class="pl-k">sizeof</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>*(<span class="pl-c1">%p</span>) =&gt; <span class="pl-c1">%p</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, ptr2, *(<span class="pl-k">void</span>**) ptr2);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%s</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, start);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Remember: <span class="pl-c1">%s</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, middle);

    <span class="pl-c1">unflatten_fini</span>();
    <span class="pl-c1">fclose</span>(in);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/4-out
# Unflattening done. Summary:
  Image read time: 0.000037s
  Fixing memory time: 0.000001s
  Total time: 0.000068s
  Total bytes read: 151
&amp;start: 0x7ffe7454eae0 -&gt; 0x8de2a0
&amp;middle: 0x7ffe7454eae8 -&gt; 0x8de2c9
*(0x8de2e7) =&gt; 0x8de2a0
*(0x8de2ef) =&gt; 0x8de2c9
You don't need to be great to start, but you need to start to be great
Remember: you need to start to be great
</code></pre>

<p>New memory area is created in the allocated storage area (the heap) and memory image is read in:<br></p>

<pre><code>0x8de2a0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f] [0x47,0x4f]
                                 ^
                                 0x8de2c9
</code></pre>

<p>Now we read two pointer offsets (0x47 and 0x4f) and fix two pointers at these offsets by adding the initial address of the allocated memory area to the position independent pointer value:<br></p>

<pre><code>0x8de2a0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x8de2a0|0x8de2c9] [0x47,0x4f] [0x47,0x4f]
                                 ^                     ^        ^         ^ pointer offset array
                                 0x8de2c9              0x47     0x4f                   ^
                                                       ^        ^                      root pointer offset array
                                                       0x8de2e7 0x8de2ef
</code></pre>

<p>Now the first pointer points at the beginning of the string and second points in the middle. This process is called linking and this is what the line <code>Linked 2 pointers</code> was talking about.<br></p>

<p>Finally we read two root pointers at offset location 0x47 and 0x4f which happens to be the same values as the only two pointers, create their storage and set the translated values:<br></p>

<pre><code>&amp;start: 0x7ffe7454eae0 -&gt; 0x8de2a0
&amp;middle: 0x7ffe7454eae8 -&gt; 0x8de2c9
</code></pre>

<p>To finally confirm the example we will move start pointer (and the second pointer) by the length of the string and read the value stored at the resulting location:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">const</span> <span class="pl-k">void</span>* ptr1 = start + strlen(start) + <span class="pl-c1">1</span>;
<span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>*(<span class="pl-c1">%p</span>) =&gt; <span class="pl-c1">%p</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, ptr1, *(<span class="pl-k">void</span>**)ptr1);
<span class="pl-k">const</span> <span class="pl-k">void</span>* ptr2 = start + strlen(start) + <span class="pl-c1">1</span> + <span class="pl-k">sizeof</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*);
<span class="pl-en">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>*(<span class="pl-c1">%p</span>) =&gt; <span class="pl-c1">%p</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, ptr2, *(<span class="pl-k">void</span>**)ptr2);</pre></div>

<pre><code>*(0x8de2e7) =&gt; 0x8de2a0
*(0x8de2ef) =&gt; 0x8de2c9
</code></pre>

<p>There is actually more you can do with pointers. For instance you can manage arrays of pointers in similar fashion:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">const</span> <span class="pl-k">char</span>* argv[] = { <span class="pl-s"><span class="pl-pds">"</span>Program name<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Argument 0<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Argument 1<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>Argument 2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Argument 3<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span> };

    <span class="pl-c1">FOR_ROOT_POINTER</span>(argv,
        <span class="pl-c1">FOREACH_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, arg, argv,
                <span class="pl-c1">ptrarrmemlen</span>((<span class="pl-k">const</span> <span class="pl-k">void</span> * <span class="pl-k">const</span>*)argv),
            <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, arg);
            <span class="pl-c1">FLATTEN_STRING</span>(arg);
        );
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/5-in
# Flattening done. Summary:
  Memory size: 105 bytes
  Linked 5 pointers
  Written 185 bytes
</code></pre>

<p>Here, for each pointer in the array <code>argv</code> we create temporary variable <code>arg</code> of type <code>const char*</code> which we can use in the subsequent block of code. We must specify the size of the array. We might know it in advance or we can compute it in real time. In case of arrays terminated with pointer 0 (NULL pointer) there is function <code>ptrarrmemlen</code> available for this purpose. It simply iterates through entire pointer array and counts the pointers until it reaches the pointer 0 (and counts it as well). Similar function is used internally by the <code>FLATTEN_STRING</code> macro, i.e. <code>strmemlen</code> function which returns the length of string including NULL terminating 0 value.<br></p>

<p>In the code body we first flatten the pointer itself and then we flatten the string pointed to by it.<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdint.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* in = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(in);
    <span class="pl-c1">unflatten_init</span>();

    <span class="pl-c1">assert</span>(<span class="pl-c1">unflatten_read</span>(in) == <span class="pl-c1">0</span>);

    <span class="pl-k">const</span> <span class="pl-k">char</span>** argv = <span class="pl-c1">ROOT_POINTER_NEXT</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>**);
    <span class="pl-k">while</span> (*argv) {
        <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%s</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, *argv);
        argv++;
    }

    <span class="pl-c1">unflatten_fini</span>();
    <span class="pl-c1">fclose</span>(in);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/5-out
# Unflattening done. Summary:
  Image read time: 0.000057s
  Fixing memory time: 0.000001s
  Total time: 0.000104s
  Total bytes read: 185
Program name
Argument 0
Argument 1
Argument 2
Argument 3
</code></pre>

<p>We finally came to the last (and most interesting) part where all the fun really begins, i.e. flattening C structures. Flattening C structure is as simple as:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FLATTEN_STRUCT</span>(type, pointer);</pre></div>

<p>However you have to provide recipe how to actually flatten structure internal fields. In the below example we want to flatten structure <code>figure</code> (which happens to be a square):<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">struct</span> point {
    <span class="pl-k">double</span> x;
    <span class="pl-k">double</span> y;
};

<span class="pl-k">struct</span> edge {
    <span class="pl-k">struct</span> point p[<span class="pl-c1">2</span>];
    <span class="pl-k">struct</span> edge* e;
};

<span class="pl-k">struct</span> figure {
    <span class="pl-k">const</span> <span class="pl-k">char</span>* name;
    <span class="pl-k">struct</span> edge* e;
};

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(figure);

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">struct</span> point sqv[<span class="pl-c1">4</span>] = {{<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>}, {<span class="pl-c1">1.0</span>, -<span class="pl-c1">1.0</span>}, {-<span class="pl-c1">1.0</span>, -<span class="pl-c1">1.0</span>}, {-<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>}};
    <span class="pl-k">struct</span> edge sqe[<span class="pl-c1">4</span>] = {
            { {sqv[<span class="pl-c1">0</span>],sqv[<span class="pl-c1">1</span>]}, &amp;sqe[<span class="pl-c1">1</span>] },
            { {sqv[<span class="pl-c1">1</span>],sqv[<span class="pl-c1">2</span>]}, &amp;sqe[<span class="pl-c1">2</span>] },
            { {sqv[<span class="pl-c1">2</span>],sqv[<span class="pl-c1">3</span>]}, &amp;sqe[<span class="pl-c1">3</span>] },
            { {sqv[<span class="pl-c1">3</span>],sqv[<span class="pl-c1">0</span>]}, &amp;sqe[<span class="pl-c1">0</span>] }
    };

    <span class="pl-k">struct</span> figure square = { <span class="pl-s"><span class="pl-pds">"</span>square<span class="pl-pds">"</span></span>, sqe };

    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>sizeof(struct figure): <span class="pl-c1">%zu</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, <span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> figure));

    <span class="pl-c1">FOR_ROOT_POINTER</span>(&amp;square,
        <span class="pl-c1">FLATTEN_STRUCT</span>(figure, &amp;square);
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/6-in_a
sizeof(struct figure): 16
# Flattening done. Summary:
  Memory size: 16 bytes
  Linked 0 pointers
  Written 56 bytes
</code></pre>

<p>As we can see the structure has been actually flattened but quick glance reveals that not everything might have gone as expected. We have just written 16 bytes (the size of the structure) itself but no internal fields has been touched (and they will point to the vain after reading them out).<br></p>

<p>The function providing the recipe how to flatten internal structure fields is called <code>FUNCTION_DEFINE_FLATTEN_STRUCT</code>. We should provide the type of the structure and the code responsible for writing structure content. Let's workout the example a little more and add the following functions:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(edge,
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(edge, e);
);

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(figure,
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(name);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(edge, e);
);</pre></div>

<pre><code>$ examples/6-in_b
sizeof(struct figure): 16
# Flattening done. Summary:
  Memory size: 183 bytes
  Linked 6 pointers
  Written 271 bytes
</code></pre>

<p>Voila! By adding several lines of code we managed to write down the whole figure properly resolving all pointers along the way.<br>
So far we have seen several functions for writing memory image, i.e.:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FLATTEN_STRING</span>(pointer)
FLATTEN_TYPE(type, pointer)
FLATTEN_TYPE_ARRAY(type, pointer, size)
FLATTEN_STRUCT(type, pointer)</pre></div>

<p>There is one more function we can use to save memory structures:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FLATTEN_STRUCT_ARRAY</span>(type, pointer, size)</pre></div>

<p>It's actually a convenience function that takes the burden of serializing a structure array pointer by pointer off from the user. It is needed to bring the following definition when using it:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">INLINE_FUNCTION_DEFINE_FLATTEN_STRUCT_ARRAY</span>(type)</pre></div>

<p>Each of these five functions has so called AGGREGATE counterparts, i.e.:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(field)
AGGREGATE_FLATTEN_TYPE(type, field)
AGGREGATE_FLATTEN_TYPE_ARRAY(type, field, size)
AGGREGATE_FLATTEN_STRUCT(type, field)
AGGREGATE_FLATTEN_STRUCT_ARRAY(type, field, size)</pre></div>

<p>Instead of pointer to variable we use the corresponding field name from within the structure.<br></p>

<p>If we want to use the field name itself for other purpose (i.e. length of the array for some other structure field) we have available macro:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">ATTR</span>(field)</pre></div>

<p>Finally to bring the structure flattening functions declarations across translation units we can use macro:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FUNCTION_DECLARE_FLATTEN_STRUCT</span>(type)</pre></div>

<p>Please note that in the above example we didn't write function recipe for flattening the <code>struct point</code>. We also omitted field <code>p</code> from the <code>struct edge</code>. These values are part of internal structure storage (they are not pointers) therefore there's no need for recursive resolution of those fields (they will be flattened together with the original structure storage).<br></p>

<p>Reading up the square structure from memory image is straightforward:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdint.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>math.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">struct</span> point {
    <span class="pl-k">double</span> x;
    <span class="pl-k">double</span> y;
};

<span class="pl-k">struct</span> edge {
    <span class="pl-k">struct</span> point p[<span class="pl-c1">2</span>];
    <span class="pl-k">struct</span> edge* e;
};

<span class="pl-k">struct</span> figure {
    <span class="pl-k">const</span> <span class="pl-k">char</span>* name;
    <span class="pl-k">struct</span> edge* e;
};

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* in = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(in);
    <span class="pl-c1">unflatten_init</span>();

    <span class="pl-c1">assert</span>(<span class="pl-c1">unflatten_read</span>(in) == <span class="pl-c1">0</span>);

    <span class="pl-k">const</span> <span class="pl-k">struct</span> figure* square = <span class="pl-c1">ROOT_POINTER_NEXT</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> figure*);

    <span class="pl-k">struct</span> edge* e = square-&gt;e;
    <span class="pl-k">double</span> circumference = <span class="pl-c1">0</span>;
    <span class="pl-k">do</span> {
        circumference += <span class="pl-c1">sqrt</span>(
                <span class="pl-c1">pow</span>(e-&gt;p[<span class="pl-c1">0</span>].<span class="pl-smi">x</span> - e-&gt;p[<span class="pl-c1">1</span>].<span class="pl-smi">x</span>, <span class="pl-c1">2</span>) + <span class="pl-c1">pow</span>(e-&gt;p[<span class="pl-c1">0</span>].<span class="pl-smi">y</span> - e-&gt;p[<span class="pl-c1">1</span>].<span class="pl-smi">y</span>, <span class="pl-c1">2</span>));
        e = e-&gt;e;
    } <span class="pl-k">while</span> (e != square-&gt;e);

    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%s</span> circumference: <span class="pl-c1">%f</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, square-&gt;name, circumference);

    <span class="pl-c1">unflatten_fini</span>();
    <span class="pl-c1">fclose</span>(in);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/6-out
# Unflattening done. Summary:
  Image read time: 0.000051s
  Fixing memory time: 0.000001s
  Total time: 0.000095s
  Total bytes read: 271
square circumference: 8.000000
</code></pre>

<p>It would be also possible to flatten the entire structure with all links using mere pointer flattening functions but in that case we would need to implement the recursive structure member resolution by ourselves:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">struct</span> point {
    <span class="pl-k">double</span> x;
    <span class="pl-k">double</span> y;
};

<span class="pl-k">struct</span> edge {
    <span class="pl-k">struct</span> point p[<span class="pl-c1">2</span>];
    <span class="pl-k">struct</span> edge* e;
};

<span class="pl-k">struct</span> figure {
    <span class="pl-k">const</span> <span class="pl-k">char</span>* name;
    <span class="pl-k">struct</span> edge* e;
};

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">struct</span> point sqv[<span class="pl-c1">4</span>] = {{<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>}, {<span class="pl-c1">1.0</span>, -<span class="pl-c1">1.0</span>}, {-<span class="pl-c1">1.0</span>, -<span class="pl-c1">1.0</span>}, {-<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>}};
    <span class="pl-k">struct</span> edge sqe[<span class="pl-c1">4</span>] = {
            { {sqv[<span class="pl-c1">0</span>],sqv[<span class="pl-c1">1</span>]}, &amp;sqe[<span class="pl-c1">1</span>] },
            { {sqv[<span class="pl-c1">1</span>],sqv[<span class="pl-c1">2</span>]}, &amp;sqe[<span class="pl-c1">2</span>] },
            { {sqv[<span class="pl-c1">2</span>],sqv[<span class="pl-c1">3</span>]}, &amp;sqe[<span class="pl-c1">3</span>] },
            { {sqv[<span class="pl-c1">3</span>],sqv[<span class="pl-c1">0</span>]}, &amp;sqe[<span class="pl-c1">0</span>] }
    };

    <span class="pl-k">struct</span> figure square = { <span class="pl-s"><span class="pl-pds">"</span>square<span class="pl-pds">"</span></span>, sqe };

    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>sizeof(struct figure): <span class="pl-c1">%zu</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, <span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> figure));

    <span class="pl-c1">FOR_ROOT_POINTER</span>(&amp;square,
        <span class="pl-c1">FOR_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, n, &amp;square.<span class="pl-smi">name</span>,
            <span class="pl-c1">FLATTEN_STRING</span>(n);
        );
        <span class="pl-c1">FOR_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, n, &amp;square.<span class="pl-smi">e</span>,
            <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">struct</span> edge*,n);
        );
        <span class="pl-k">struct</span> edge* e = square.<span class="pl-smi">e</span>;
        <span class="pl-k">do</span> {
            <span class="pl-c1">FOR_POINTER</span>(<span class="pl-k">struct</span> edge*, pe, &amp;e-&gt;e,
                <span class="pl-c1">FLATTEN_TYPE_ARRAY</span>(<span class="pl-k">struct</span> point,pe-&gt;p, <span class="pl-c1">2</span>);
                <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">struct</span> edge*, pe);
            );
            e = e-&gt;e;
        } <span class="pl-k">while</span>(e!=square.<span class="pl-smi">e</span>);
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/6-in_c
sizeof(struct figure): 16
# Flattening done. Summary:
  Memory size: 183 bytes
  Linked 6 pointers
  Written 271 bytes
</code></pre>

<p>In the final example we will try to pressure the library a little bit and notice how it responds to more demanding job. Let's modify the previous example and try to approximate a circle. To avoid stack overflow (in the previous example walking through the edges during flattening stage required one recursive call deeper per each edge) we will modify the structures slightly. <code>struct figure</code> will hold a table of all points and each point will hold a pointer to each other point in the polygon. We will build regular polygon with points around the circle circumference of radius 1. When number of points is 8 it would look something like below:<br></p>

<p><img src="https://github.com/braton/libflat/blob/gh-pages/images/figure_1.JPG" alt="Figure 1"></p>

<p>We will describe the flattening recipe for each structure as in the full example below:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>math.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">struct</span> point {
    <span class="pl-k">double</span> x;
    <span class="pl-k">double</span> y;
    <span class="pl-k">unsigned</span> n;
    <span class="pl-k">struct</span> point** other;
};

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(point,
    <span class="pl-en">AGGREGATE_FLATTEN_TYPE_ARRAY</span>(<span class="pl-k">struct</span> point*, other, ATTR(n));
    <span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">struct</span> point*, p, ATTR(other), ATTR(n),
            FLATTEN_STRUCT(point, p);
    );
);

<span class="pl-k">struct</span> figure {
    <span class="pl-k">const</span> <span class="pl-k">char</span>* name;
    <span class="pl-k">unsigned</span> n;
    <span class="pl-k">struct</span> point* points;
};

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(figure,
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(name);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT_ARRAY</span>(point,points,ATTR(n));
);

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">int</span> argc, <span class="pl-k">char</span>** argv) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-c1">assert</span>(argc &gt; <span class="pl-c1">1</span>);
    <span class="pl-k">struct</span> figure circle = { <span class="pl-s"><span class="pl-pds">"</span>circle<span class="pl-pds">"</span></span> };
    <span class="pl-c1">assert</span>(<span class="pl-c1">sscanf</span>(argv[<span class="pl-c1">1</span>], <span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%u</span><span class="pl-pds">"</span></span>, &amp;circle.<span class="pl-smi">n</span>) == <span class="pl-c1">1</span>);
    <span class="pl-c1">assert</span>(circle.<span class="pl-smi">n</span> &gt; <span class="pl-c1">1</span>);
    circle.<span class="pl-smi">points</span> = <span class="pl-c1">calloc</span>(circle.<span class="pl-smi">n</span>, <span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> point));
    <span class="pl-c1">assert</span>(circle.<span class="pl-smi">points</span>);
    <span class="pl-k">double</span> radius = <span class="pl-c1">1.0</span>, angle = <span class="pl-c1">2</span> * M_PI / circle.<span class="pl-smi">n</span>;

#<span class="pl-k">define</span> <span class="pl-en">MAKE_POINT</span>(<span class="pl-v">p, i, N</span>)   \
    p.<span class="pl-smi">x</span> = <span class="pl-c1">cos</span>(angle*(radius*(i)));  \
    p.<span class="pl-smi">y</span> = <span class="pl-c1">sin</span>(angle*(radius*(i)));  \
    p.<span class="pl-smi">n</span> = (N);  \
    p.<span class="pl-smi">other</span> = <span class="pl-c1">calloc</span>((N), <span class="pl-k">sizeof</span>*p.<span class="pl-smi">other</span>);   \
    <span class="pl-c1">assert</span>(p.<span class="pl-smi">other</span>);

    <span class="pl-k">unsigned</span> i, j;
    <span class="pl-k">for</span> (i = <span class="pl-c1">0</span>; i &lt; circle.<span class="pl-smi">n</span>; ++i) {
        <span class="pl-c1">MAKE_POINT</span>(circle.<span class="pl-smi">points</span>[i], i, circle.<span class="pl-smi">n</span> - <span class="pl-c1">1</span>);
    }
    <span class="pl-k">for</span> (i = <span class="pl-c1">0</span>; i &lt; circle.<span class="pl-smi">n</span>; ++i) {
        <span class="pl-k">unsigned</span> u = <span class="pl-c1">0</span>;
        <span class="pl-k">for</span> (j = <span class="pl-c1">0</span>; j &lt; circle.<span class="pl-smi">n</span>; ++j) {
            <span class="pl-k">if</span> (i == j)
                <span class="pl-k">continue</span>;
            circle.<span class="pl-smi">points</span>[i].<span class="pl-smi">other</span>[u++] = &amp;circle.<span class="pl-smi">points</span>[j];
        }
    }

    <span class="pl-c1">FOR_ROOT_POINTER</span>(&amp;circle,
        <span class="pl-c1">FLATTEN_STRUCT</span>(figure, &amp;circle);
    );

    <span class="pl-k">for</span> (i = <span class="pl-c1">0</span>; i &lt; circle.<span class="pl-smi">n</span>; ++i) {
        <span class="pl-c1">free</span>(circle.<span class="pl-smi">points</span>[i].<span class="pl-smi">other</span>);
    }
    <span class="pl-c1">free</span>(circle.<span class="pl-smi">points</span>);

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<p>The example code allows us to specify the number of points we want to process, e.g.:<br></p>

<pre><code>$ examples/circular-in 8
</code></pre>

<p>Depending on the size of available memory (and available disk space and time) we might set the value accordingly. For the following value we have got:<br></p>

<pre><code>$ examples/circular-in 10000
# Flattening done. Summary:
  Memory size: 800240031 bytes
  Linked 100000002 pointers
  Written 1600240087 bytes
</code></pre>

<p>On the other side we will now read the entire image and try to calculate several properties of our close to circle polygon. These would be number of edges, sum of lengths of edges and diagonals and finally the approximated circumference (in the example we will walk through all the points and count the edges/diagonals and their lengths; after walking from point A to point B we will break the connection between B and A (by setting the B pointer to 0)):<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdint.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>math.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">struct</span> point {
    <span class="pl-k">double</span> x;
    <span class="pl-k">double</span> y;
    <span class="pl-k">unsigned</span> n;
    <span class="pl-k">struct</span> point** other;
};

<span class="pl-k">struct</span> figure {
    <span class="pl-k">const</span> <span class="pl-k">char</span>* name;
    <span class="pl-k">unsigned</span> n;
    <span class="pl-k">struct</span> point* points;
};

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* in = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>r<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(in);
    <span class="pl-c1">unflatten_init</span>();

    <span class="pl-c1">assert</span>(<span class="pl-c1">unflatten_read</span>(in) == <span class="pl-c1">0</span>);

    <span class="pl-k">const</span> <span class="pl-k">struct</span> figure* circle = <span class="pl-c1">ROOT_POINTER_NEXT</span>(<span class="pl-k">const</span> <span class="pl-k">struct</span> figure*);

    <span class="pl-k">unsigned</span> i, j;
    <span class="pl-k">double</span> length = <span class="pl-c1">0</span>, circumference = <span class="pl-c1">0</span>;
    <span class="pl-k">unsigned</span> edge_number = <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (i = <span class="pl-c1">0</span>; i &lt; circle-&gt;n - <span class="pl-c1">1</span>; ++i) {
        <span class="pl-k">for</span> (j = i; j &lt; circle-&gt;n - <span class="pl-c1">1</span>; ++j) {
            <span class="pl-k">if</span> (circle-&gt;points[i].<span class="pl-smi">other</span>[j]) {

                <span class="pl-k">double</span> path_len = <span class="pl-c1">sqrt</span>( <span class="pl-c1">pow</span>(circle-&gt;points[i].<span class="pl-smi">x</span>-circle-&gt;points[i].<span class="pl-smi">other</span>[j]-&gt;x, <span class="pl-c1">2</span>) +
                        <span class="pl-c1">pow</span>(circle-&gt;points[i].<span class="pl-smi">y</span>-circle-&gt;points[i].<span class="pl-smi">other</span>[j]-&gt;y, <span class="pl-c1">2</span>) );
                length += path_len;

                <span class="pl-k">if</span> (j == i)
                    circumference += path_len;
                <span class="pl-k">if</span> ((i == <span class="pl-c1">0</span>) &amp;&amp; (j == circle-&gt;n - <span class="pl-c1">2</span>))
                    circumference += path_len;

                <span class="pl-k">unsigned</span> u;
                <span class="pl-k">for</span> (u = <span class="pl-c1">0</span>; u &lt; circle-&gt;n - <span class="pl-c1">1</span>; ++u) {
                    <span class="pl-k">if</span> (circle-&gt;points[i].<span class="pl-smi">other</span>[j]-&gt;other[u] == &amp;circle-&gt;points[i]) {
                        circle-&gt;points[i].<span class="pl-smi">other</span>[j]-&gt;other[u] = <span class="pl-c1">0</span>;
                    }
                }
                edge_number++;
            }
        }
    }

    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Number of edges/diagonals: <span class="pl-c1">%u</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, edge_number);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Sum of lengths of edges/diagonals: <span class="pl-c1">%.17f</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, length);
    <span class="pl-c1">printf</span>(<span class="pl-s"><span class="pl-pds">"</span>Half of the circumference: <span class="pl-c1">%.17f</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, circumference / <span class="pl-c1">2</span>);

    <span class="pl-c1">unflatten_fini</span>();
    <span class="pl-c1">fclose</span>(in);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<p>Running the example with warm caches yields:<br></p>

<pre><code>$ examples/circular-out
# Unflattening done. Summary:
  Image read time: 0.303173s
  Fixing memory time: 0.112452s
  Total time: 0.415674s
  Total bytes read: 1600240087
Number of edges: 49995000
Sum of lengths of edges/diagonals: 63661976.71272929012775421
Half of the circumference: 3.14159260191227308
</code></pre>

<p>Clearing the cache makes things slower as expected:<br></p>

<pre><code>$ echo 1 &gt; /proc/sys/vm/drop_caches
$ examples/circular-out
# Unflattening done. Summary:
  Image read time: 4.053782s
  Fixing memory time: 0.114766s
  Total time: 4.168599s
  Total bytes read: 1600240087
</code></pre>

<p>As showed it the example above unflattening depends mostly on the disk image read time and any further potential optimizations would need be focused on that part.<br></p>

<h2>
<a id="implementation-details" class="anchor" href="#implementation-details" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implementation details</h2>

<p>Libflat works by making copy of the process memory for indicated variables and structures. There are three main data structures fundamental to the Libflat operation, i.e.:</p>

<ul>
<li>interval tree that holds information about fragments of memory image currently being flattened (implemented by the struct interval_tree_node structure);<br>
</li>
<li>double linked list of binary data blocks that holds fragments of memory image currently being flattened (implemented by the structure struct blstream);<br>
</li>
<li>red-black tree of fix-up information elements that hold information about parts of memory that need to be fixed (linked) after reading-in the memory image.<br>
</li>
</ul>

<p>Consider the following example:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>limits.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">struct</span> internal_type {
    <span class="pl-k">int</span> u:<span class="pl-c1">4</span>;
    <span class="pl-k">char</span> c;
};

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(internal_type);

<span class="pl-k">struct</span> type {
    <span class="pl-k">const</span> <span class="pl-k">char</span>* name;
    <span class="pl-k">unsigned</span> <span class="pl-k">long</span> v;
    <span class="pl-k">struct</span> type* next;
    <span class="pl-k">struct</span> internal_type* internal[<span class="pl-c1">4</span>];
};

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(type,
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(name);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(type, next);
    <span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">struct</span> internal_type*, p, ATTR(internal), 4,
        FLATTEN_STRUCT(internal_type, p);
    );
);

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">char</span>* st[] = {
        <span class="pl-s"><span class="pl-pds">"</span>string0<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>string1<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>string2<span class="pl-pds">"</span></span>,
        <span class="pl-c1">0</span>
    };

    <span class="pl-k">static</span> <span class="pl-k">struct</span> internal_type u = { .<span class="pl-smi">u</span>=<span class="pl-c1">1</span>, .<span class="pl-smi">c</span>=<span class="pl-s"><span class="pl-pds">'</span>#<span class="pl-pds">'</span></span> };
    <span class="pl-k">static</span> <span class="pl-k">struct</span> internal_type w = { .<span class="pl-smi">u</span>=<span class="pl-c1">2</span>, .<span class="pl-smi">c</span>=<span class="pl-s"><span class="pl-pds">'</span>@<span class="pl-pds">'</span></span> };

    <span class="pl-k">struct</span> type* alloc_type = <span class="pl-c1">calloc</span>(<span class="pl-c1">1</span>, <span class="pl-k">sizeof</span>(<span class="pl-k">struct</span> type));
        alloc_type-&gt;name = st[<span class="pl-c1">2</span>] + <span class="pl-c1">2</span>;
        alloc_type-&gt;next = alloc_type;
        alloc_type-&gt;internal[<span class="pl-c1">0</span>] = &amp;u;
        alloc_type-&gt;internal[<span class="pl-c1">1</span>] = &amp;w;

    <span class="pl-k">struct</span> type type_arr[<span class="pl-c1">2</span>] = {
            { .<span class="pl-smi">name</span>=<span class="pl-s"><span class="pl-pds">"</span>type1<span class="pl-pds">"</span></span>, .<span class="pl-smi">v</span>=UINT_MAX, &amp;type_arr[<span class="pl-c1">1</span>], {&amp;u, &amp;u, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>}  },
            {  st[<span class="pl-c1">1</span>], .<span class="pl-smi">v</span>=<span class="pl-c1">0</span>, alloc_type, {<span class="pl-c1">0</span>} }
    };

    <span class="pl-k">struct</span> type* root_ptr = &amp;type_arr[<span class="pl-c1">0</span>];

    <span class="pl-c1">FOR_ROOT_POINTER</span>(root_ptr,
        <span class="pl-c1">FLATTEN_STRUCT</span>(type, root_ptr);
    );

    <span class="pl-c1">FOR_ROOT_POINTER</span>(st,
        <span class="pl-c1">FOREACH_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, s, st, <span class="pl-c1">ptrarrmemlen</span>((<span class="pl-k">const</span> <span class="pl-k">void</span>* <span class="pl-k">const</span>*)st),
            <span class="pl-c1">FLATTEN_STRING</span>(s);
        );
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);
    <span class="pl-c1">free</span>(alloc_type);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/7-in
(...)
</code></pre>

<p>Let's draw the original memory image that is about to be serialized. It might look like below.<br></p>

<pre><code>(automatic storage)

st:         [    0x401a53    ][    0x401a5b    ][    0x401a63    ][ 0 ]
            ^                 ^                 ^                 ^
            0x7ffec43881e0    0x7ffec43881e8    0x7ffec43881f0    0x7ffec43881f8
w:          [ 4B ]
            ^
            0x7ffec43881d0
type_arr:   [ ...  56B  ... ][ ...  56B  ... ]
            ^                ^
            0x7ffec4388200   0x7ffec4388238

(allocated storage)

alloc_type: [ ...  56B  ... ]
            ^
            0x101e250

(static storage)

st[0]:      ['s'|'t'|'r'|'i'|'n'|'g'|'0'|0]
            ^
            0x401a53

st[1]:      ['s'|'t'|'r'|'i'|'n'|'g'|'1'|0]
            ^
            0x401a5b

st[2]:      ['s'|'t'|'r'|'i'|'n'|'g'|'2'|0]
            ^
            0x401a63

u:          [ 4B ]
            ^
            0x6030f8

type_arr[0].name:   ['t'|'y'|'p'|'e'|'1'|0]
                    ^
                    0x401a6b
</code></pre>

<p>First item that goes through flattening is the structure pointed by <code>root_ptr (&amp;type_arr[0])</code>. This happens in the macro:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FLATTEN_STRUCT</span>(type, root_ptr);</pre></div>

<p>If we expand this macro we might see the following code:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> flatten_pointer* __fptr = make_flatten_pointer(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>);
<span class="pl-k">if</span> (root_ptr) {
    <span class="pl-c1">fixup_set_insert</span>(__fptr-&gt;node, __fptr-&gt;offset, <span class="pl-c1">flatten_struct_type</span>((root_ptr)));
}
<span class="pl-en">free</span>(__fptr);</pre></div>

<p>The function <code>flatten_struct_type</code> is defined by the <code>FUNCTION_DEFINE_FLATTEN_STRUCT(type,...)</code> macro and takes the pointer to <code>struct type</code> that is about to be flattened as a parameter. The first thing it does is to create new interval fragment in the memory interval tree that corresponds to this structure location:<br></p>

<pre><code>[0x7ffec4388200:0x7ffec4388237] =&gt; [ 56B ]
^                                  ^
0x101e2b0                          0x101e2f0
</code></pre>

<p>This interval is described by <code>struct interval_tree_node</code> structure, specifically by its <code>start</code> and <code>last</code> fields. Furthermore it also holds pointer to the underlying data (the copied contents from the original structure location) through <code>struct blstream</code> instance.<br></p>

<p>In the next step it recursively calls all flattening functions defined as recipes for flattening this structure internal storage (e.g. memory pointed to by this structure internal pointers). In our case the first recursive call is <code>AGGREGATE_FLATTEN_STRING(name)</code>. Expanding it again we have:<br></p>

<p>if (_ptr-&gt;name) {
    fixup_set_insert(__node, offsetof(struct type, name), flatten_plain_type(_ptr-&gt;name, strmemlen(_ptr-&gt;name)));
}</p>

<p><code>_ptr</code> now points to the original structure;<br>
<code>__node</code> is the newly created interval for the original structure (described above).<br></p>

<p><code>flatten_plain_type</code> does similar thing as <code>flatten_struct_type</code> with the difference that it can take arbitrary memory block of specified size (and will not call any functions recursively as the content of string does not normally contain pointers to other memory regions). In our case we have string <code>type1</code> of total size 6 therefore new memory fragment of size 6 is created (we have now two memory fragments):<br></p>

<pre><code>[0x7ffec4388200:0x7ffec4388237] =&gt; [ 56B ]
[0x401a6b:0x401a70] =&gt; [ 6B ]
^                      ^
0x101e360              0x101e3a0
</code></pre>

<p>This process continues recursively for all recipes embedded into structure flattening recipes (and pointer flattening recipes, i.e. <code>FOREACH_POINTER</code>):<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(type, next);
<span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">struct</span> internal_type*, p, ATTR(internal), 4,
    FLATTEN_STRUCT(internal_type, p);
);</pre></div>

<p>Each call creates another interval fragment of original memory (and corresponding copied memory data block). If memory fragment already exists (or partially exists) it is ignored (or another memory fragment that fills the remaining memory is created). For example flattening stage in our example looks like below (you can always check how flattening stage operates by invoking <code>flatten_set_debug_flag(1)</code> before the actual serialization):<br></p>

<pre><code>(Executed function)                                     (function argument)       (created interval)
FOR_ROOT_POINTER(root_ptr)
  FLATTEN_STRUCT(type, root_ptr)                         {root_ptr}                [0x7ffec4388200:0x7ffec4388237] =&gt; [ 56B ]
    AGGREGATE_FLATTEN_STRING(name)                       {name: "type1"}           [0x401a6b:0x401a70] =&gt; [ 6B ]
    AGGREGATE_FLATTEN_STRUCT(type, next)                 {next: &amp;type_arr[1]}      [0x7ffec4388238:0x7ffec438826f] =&gt; [ 56B ]
      AGGREGATE_FLATTEN_STRING(name)                     {name: st[1]}             [0x401a5b:0x401a62] =&gt; [ 8B ]
      AGGREGATE_FLATTEN_STRUCT(type, next)               {alloc_type}              [0x101e250:0x101e287] =&gt; [ 56B ]
        AGGREGATE_FLATTEN_STRING(name)                   {st[2]+2}                 [0x401a65:0x401a6a] =&gt; [ 6B ]
        AGGREGATE_FLATTEN_STRUCT(type, next)             {alloc_type}              &lt;EXISTS&gt;
        FOREACH_POINTER(struct internal_type*, p,
                                ((_ptr)-&gt;internal), 4)
          FLATTEN_STRUCT(internal_type, p)               {&amp;u}                      [0x6030f8:0x6030fb] =&gt; [ 4B ]
          FLATTEN_STRUCT(internal_type, p)               {&amp;w}                      [0x7ffec43881d0:0x7ffec43881d3] =&gt; [ 4B ]
          FLATTEN_STRUCT(internal_type, p)               {0}                       &lt;NULL&gt;
          FLATTEN_STRUCT(internal_type, p)               {0}                       &lt;NULL&gt;
      FOREACH_POINTER(struct internal_type*, p,
                              ((_ptr)-&gt;internal), 4)
        FLATTEN_STRUCT(internal_type, p)                 {0}                       &lt;NULL&gt;
        FLATTEN_STRUCT(internal_type, p)                 {0}                       &lt;NULL&gt;
        FLATTEN_STRUCT(internal_type, p)                 {0}                       &lt;NULL&gt;
        FLATTEN_STRUCT(internal_type, p)                 {0}                       &lt;NULL&gt;
    FOREACH_POINTER(struct internal_type*, p,
                            ((_ptr)-&gt;internal), 4)
      FLATTEN_STRUCT(internal_type, p)                   {&amp;u}                      &lt;EXISTS&gt;
      FLATTEN_STRUCT(internal_type, p)                   {&amp;w}                      &lt;EXISTS&gt;
      FLATTEN_STRUCT(internal_type, p)                   {0}                       &lt;NULL&gt;
      FLATTEN_STRUCT(internal_type, p)                   {0}                       &lt;NULL&gt;

FOR_ROOT_POINTER(st)
  FOREACH_POINTER(const char*, s, st,
                ptrarrmemlen((const void* const*)st))   {&amp;st[0]}                  [0x7ffec43881e0:0x7ffec43881e7] =&gt; [ 8B ]
                                                        {&amp;st[1]}                  [0x7ffec43881e8:0x7ffec43881ef] =&gt; [ 8B ]
                                                        {&amp;st[2]}                  [0x7ffec43881f0:0x7ffec43881f7] =&gt; [ 8B ]
                                                        {&amp;st[3]}                  [0x7ffec43881f8:0x7ffec43881ff] =&gt; [ 8B ]

    FLATTEN_STRING(s)                                   {st[0]}                   [0x401a53:0x401a5a] =&gt; [ 8B ]
    FLATTEN_STRING(s)                                   {st[1]}                   &lt;EXISTS&gt;
    FLATTEN_STRING(s)                                   {st[2]}                   [0x401a63:0x401a64] =&gt; [ 2B ]
    FLATTEN_STRING(s)                                   {0}                       &lt;NULL&gt;
</code></pre>

<p>You can notice that <code>alloc_type-&gt;name</code> points inside the string <code>string2</code>. During serialization of this member only 6B of this string are written:<br></p>

<pre><code>AGGREGATE_FLATTEN_STRING(name)                  {st[2] + 2}                 [0x401a65:0x401a6a] =&gt; [ 6B ]
</code></pre>

<p>Remaining two bytes are added when the <code>string2</code> string is serialized from its beginning (parts of this string already available in memory image are omitted):<br></p>

<pre><code>FLATTEN_STRING(s)                                   {st[2]}                   [0x401a63:0x401a64] =&gt; [ 2B ]
</code></pre>

<p>It's worth to notice that function <code>FOREACH_POINTER</code> also dumps the storage of a pointer its creates before making it available for internal recipes as in:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, s, st,...)</pre></div>

<p>unless it's already been flattened as in:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">struct</span> internal_type*, p,...)</pre></div>

<p>which has been flattened as a part of the storage of the encompassing structure type (the pointer itself is a part of the structure storage).<br></p>

<p>As has been mentioned each interval structure holds pointer (<code>struct blstream*</code>) to corresponding binary data block of copied memory. All blocks are arranged in doubly linked list (in sorted order by its initial addresses) which makes adding new block anywhere in the list a fast operation (constant time).<br></p>

<p>Considering the example above before executing:<br></p>

<pre><code>FLATTEN_STRING(s)                                   {st[2]}                   [0x401a63:0x401a64] =&gt; [ 2B ]
</code></pre>

<p>the memory data list would look as follows:<br></p>

<pre><code>[ 8B ]              [ 8B ]              [ 6B ]              [ 6B ]              [ 4B ]              [ 56B ]
0x101ec60           0x101e540           0x101e6e0           0x101e3a0           0x101e850           0x101e630
^                   ^                   ^                   ^                   ^                   ^
[0x401a53:0x401a5a] [0x401a5b:0x401a62] [0x401a65:0x401a6a] [0x401a6b:0x401a70] [0x6030f8:0x6030fb] [0x101e250:0x101e287]
^                   ^                   ^                   ^                   ^                   ^
0x101ec20           0x101e500           0x101e6a0           0x101e360           0x101e810           0x101e5f0


[ 4B ]                          [ 8B ]                          [ 8B ]                          [ 8B ]                          [ 8B ]
0x101e940                       0x101ebb0                       0x101ed50                       0x101ee40                       0x101efc0
^                               ^                               ^                               ^                               ^
[0x7ffec43881d0:0x7ffec43881d3] [0x7ffec43881e0:0x7ffec43881e7] [0x7ffec43881e8:0x7ffec43881ef] [0x7ffec43881f0:0x7ffec43881f7] [0x7ffec43881f8:0x7ffec43881ff]
^                               ^                               ^                               ^                               ^
0x101e900                       0x101eb70                       0x101ed10                       0x101ee00                       0x101ef80


[ 56B ]                         [ 56B ]
0x101e2f0                       0x101e490
^                               ^
[0x7ffec4388200:0x7ffec4388237] [0x7ffec4388238:0x7ffec438826f]
^                               ^
0x101e2b0                       0x101e450
</code></pre>

<p>Adding two more bytes with initial address 0x401a63 inserts the data between 2nd and 3rd element in the list:<br></p>

<pre><code>[ 8B ]              [ 8B ]              [ 2B ]              [ 6B ]              [ 6B ]              [ 4B ]              [ 56B ]
0x101ec60           0x101e540           0x101eed0           0x101e6e0           0x101e3a0           0x101e850           0x101e630
^                   ^                   ^                   ^                   ^                   ^                   ^
[0x401a53:0x401a5a] [0x401a5b:0x401a62] [0x401a63:0x401a64] [0x401a65:0x401a6a] [0x401a6b:0x401a70] [0x6030f8:0x6030fb] [0x101e250:0x101e287] ...
^                   ^                   ^                   ^                   ^                   ^                   ^
0x101ec20           0x101e500           0x101ee90           0x101e6a0           0x101e360           0x101e810           0x101e5f0
</code></pre>

<p>Interval tree structure is implemented on top of the red-black trees (credits to the original Linux kernel developers from where this implementation has been taken). This also makes searching for the given interval a linearithmic operation.<br></p>

<p>The final data structure used internally is so called fixup set. It's a standard set data structure build on top of red-black tree. Remember that parts of the memory image are linked together through pointers. We have 13 non-zero pointers in the working example above inside our 238B memory image, i.e.:<br></p>

<div class="highlight highlight-source-c"><pre>type_arr[<span class="pl-c1">0</span>].name
type_arr[<span class="pl-c1">0</span>].next
type_arr[<span class="pl-c1">0</span>].internal[<span class="pl-c1">0</span>]
type_arr[<span class="pl-c1">0</span>].internal[<span class="pl-c1">1</span>]
type_arr[<span class="pl-c1">1</span>].name
type_arr[<span class="pl-c1">1</span>].next
alloc_type-&gt;name
alloc_type-&gt;next
alloc_type-&gt;internal[<span class="pl-c1">0</span>]
alloc_type-&gt;internal[<span class="pl-c1">1</span>]
st[<span class="pl-c1">0</span>]
st[<span class="pl-c1">1</span>]
st[<span class="pl-c1">2</span>]</pre></div>

<p>During saving memory image we need to somehow mark all pointer locations which should be later fixed (new address should be recomputed) after deserialization. To facilitate that we store all pointer locations within memory image in the fixup set. Fixup set is represented by the <code>fixup_set_node</code> structure which defines the mapping (one element of a set) as follows:<br></p>

<pre><code>( {node:offset} =&gt; {node:offset} )
</code></pre>

<p>Standard memory pointers in most cases are represented by numbers (although C standard does not require that) which are addresses of some memory locations, i.e.</p>

<pre><code>type_arr[0].next : 0x7ffec4388210
</code></pre>

<p>Flatten memory representation is composed of the list of memory intervals. Therefore to represent the above pointer in flatten memory image we need to tell which interval holds the pointer storage at which offset within this interval. In the above case the <code>next</code> pointer is a part of <code>struct type</code> structure which is stored at interval:<br></p>

<pre><code>[ 56B ]
0x101e2f0
^
[0x7ffec4388200:0x7ffec4388237]
^
0x101e2b0
</code></pre>

<p>The address of this interval is 0x101e2b0, and <code>next</code> pointer is stored at offset 16 within this interval. All this leads to the following flatten pointer representation (<code>struct flatten_pointer</code> in the code) that points to the part of flatten memory:<br></p>

<pre><code>{0x101e2b0:16}
</code></pre>

<p>In our case <code>next</code> field points to <code>type_arr[1]</code> structure which flatten pointer is:</p>

<pre><code>{0x101e450:0}
</code></pre>

<p>Finally the mapping which is stored in fixup set (there is one mapping for each original pointer) has the form:<br></p>

<pre><code>( {0x101e2b0:16} =&gt; {0x101e450:0} )
</code></pre>

<p>Flatten pointers are inserted in fixup set by the function <code>fixup_set_insert</code>. Going back to our expanded code from the beginning of this section we have:</p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">if</span> (_ptr-&gt;name) {
    <span class="pl-c1">fixup_set_insert</span>(__node, <span class="pl-c1">offsetof</span>(<span class="pl-k">struct</span> type, name), <span class="pl-c1">flatten_plain_type</span>(_ptr-&gt;name, <span class="pl-c1">strmemlen</span>(_ptr-&gt;name)));
}</pre></div>

<p>Here we insert the mapping:<br></p>

<pre><code>( {__node:offsetof(struct type,name)} =&gt; (...) )
</code></pre>

<p>with the value returned by the <code>flatten_plain_type()</code> function. In other words we might say:<br></p>

<p>"There is a pointer in the <code>struct type</code> structure at offset 0 which points to a given memory interval at given offset (returned by the flattening function); remember that and later after deserialization assign proper address value to this pointer so it will point to the original flattened object."<br></p>

<p>Root pointers does not have storage which is worked around using zeroed mapping:<br></p>

<pre><code>( {0:0} =&gt; (...) )
</code></pre>

<p>And code:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">struct</span> flatten_pointer* __fptr = make_flatten_pointer(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>);
<span class="pl-k">if</span> (root_ptr) {
    <span class="pl-c1">fixup_set_insert</span>(__fptr-&gt;node, __fptr-&gt;offset, <span class="pl-c1">flatten_struct_type</span>((root_ptr)));
}</pre></div>

<p>Zeroed mappings are not added to the fixup set (they are ignored by the <code>fixup_set_insert</code> function) as root pointers are handled differently (they are converted to the offset values from the beginnig of the image (position independent counterparts) file and stored additionally in the image header; check <code>struct root_addrnode</code> structure and its usage).<br></p>

<p>The last remaining piece to explain is how libflat prepares all pointers within the image so only one simple fix is required after deserialization. It's already been explained how the memory fixing is done (). When flattening phase is finished memory image is fully arranged of interval list with ascending order of original addresses. Next step is to compute the index at which each interval data begins (function <code>binary_stream_calculate_index</code>):<br></p>

<pre><code>{0}:[ 8B ]          {8}:[ 8B ]          {16}:[ 2B ]         {18}:[ 6B ]         {24}:[ 6B ]         {30}:[ 4B ]         {34}:[ 56B ]
0x101ec60           0x101e540           0x101eed0           0x101e6e0           0x101e3a0           0x101e850           0x101e630
^                   ^                   ^                   ^                   ^                   ^                   ^
[0x401a53:0x401a5a] [0x401a5b:0x401a62] [0x401a63:0x401a64] [0x401a65:0x401a6a] [0x401a6b:0x401a70] [0x6030f8:0x6030fb] [0x101e250:0x101e287] ...
^                   ^                   ^                   ^                   ^                   ^                   ^
0x101ec20           0x101e500           0x101ee90           0x101e6a0           0x101e360           0x101e810           0x101e5f0


{90}:[ 4B ]                     {94}:[ 8B ]                     {102}:[ 8B ]                    {110}:[ 8B ]                    {118}:[ 8B ]
0x101e940                       0x101ebb0                       0x101ed50                       0x101ee40                       0x101efc0
^                               ^                               ^                               ^                               ^
[0x7ffec43881d0:0x7ffec43881d3] [0x7ffec43881e0:0x7ffec43881e7] [0x7ffec43881e8:0x7ffec43881ef] [0x7ffec43881f0:0x7ffec43881f7] [0x7ffec43881f8:0x7ffec43881ff]
^                               ^                               ^                               ^                               ^
0x101e900                       0x101eb70                       0x101ed10                       0x101ee00                       0x101ef80


{126}:[ 56B ]                   {182}:[ 56B ]
0x101e2f0                       0x101e490
^                               ^
[0x7ffec4388200:0x7ffec4388237] [0x7ffec4388238:0x7ffec438826f]
^                               ^
0x101e2b0                       0x101e450
</code></pre>

<p>Now when we look at the mapping in the fixup set:<br></p>

<pre><code>( {0x101e2b0:16} =&gt; {0x101e450:0} )
</code></pre>

<p>we notice that the original pointer is located at offset 16 in the interval which data index is 126. This yields the final value 142. Furthermore this pointer points to interval which data index is 182 to the offset 0 (this gives the value 182). All what needs to be now done is to insert new position independent pointer value 182 at offset 142 if the flattened memory image (function <code>binary_stream_update_pointers</code>):<br></p>

<pre><code>[ | | | | ... | 182 | | | ...]
^     ^       ^
0     3       142
</code></pre>

<p>It is worth to mention that we don't need to be worried about flattening NULL pointers, we just ignore them. NULL pointer has the value 0 which can be preserved between original and flattened memory image and will have the same meaning after deserialization.<br></p>

<p>For debug purposes it is possible to dump all addresses of internal structures using the <code>flatten_debug_info()</code> function. To use the debugging functions include the following declarations into the source code as follows:<br></p>

<pre><code>void flatten_debug_info();
void flatten_set_debug_flag(int flag);
</code></pre>

<h2>
<a id="limitations" class="anchor" href="#limitations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Limitations</h2>

<p>There are several limitations to the current version of libflat which are listed below.<br></p>

<p><strong>1.</strong>  Libflat does not support serializing system elements. Examples might be <code>FILE</code> or <code>struct dirent</code> structures. Although it might be possible to write proper recipes for these structures and even flattening would be successfull. However these structures might hold values (like inode numbers, process IDs etc.) that have proper meaning only within the original process boundary. This is a hard limitation and seems impossible to resolve (unless there's anyone who doesn't yet know it's impossible) without adding additional code for restoring system elements after deserialization.<br></p>

<p><strong>2.</strong>  Current version of Libflat has limited support for flattening pointer to functions. Although it is possible to flatten the value a pointer to function points to but currently there is no possible to fix it during deserialization (there is no facility that would recognize pointers to functions and save proper fix information to be used later). It can be workaround by adding additional code after deserialization which resets pointer to functions to proper values in the new process context. However it can be burdensome (and in some cases even impossible, like original pointer to functions has been set according to the random program input). One idea is to use dynamic linker functionality, resolve function addresses within main binary or dynamically linked libraries and store resolved symbols. It would work for many cases (and therefore seems practical) however it would support only functions visible for the linker (i.e. support for static functions would be limited, but hey, who passes around static function addresses using pointer to functions? ;)).<br></p>

<p><strong>3.</strong>  After deserialization is done freeing or reallocating any pointer that was a part of memory image will invoke undefined behaviour (and very probable SIGSEGV signal or library assertion). This is due to the fact any allocated pointer in the original image is not allocated anymore after deserialization. There is only one allocation for the whole memory image that is about to be read in. Libflat provides two functions that can somehow mitigate this obstacle:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-k">void</span>* <span class="pl-en">libflat_realloc</span> (<span class="pl-k">void</span>* ptr, <span class="pl-c1">size_t</span> size);
<span class="pl-k">void</span> <span class="pl-en">libflat_free</span> (<span class="pl-k">void</span>* ptr);</pre></div>

<p>These two functions check whether the pointer that is freed/reallocated points inside flattened memory region and if this is the case free function does nothing and realloc returns new storage allocated using malloc of a given size (and copied memory content). In case of realloc we don't know how much storage was previously allocated therefore Libflat will try to copy all bytes given by the new size just to be sure (if new size exceeds the length of memory image then all bytes until end of memory image are copied). When the pointer that is freed/reallocated points outside of flattened memory normal standard free/realloc is used. Above two functions should be used instead of original free/realloc (e.g. by the preprocessor definition).<br>
Solution described above yields another problem, i.e. the flattened memory content need to stay persistent in memory even though most of the content (accessible through pointers) might be deallocated and no longer used. Future solutions might track pointers frees/allocations and rebuild memory image when appropriate (that would need to somehow pass the information about the length of allocated storage though).<br></p>

<p><strong>4.</strong>  <a name="limit4"></a>In the current version of Libflat there are some limitations for the structure and pointer overlays that can be flattened. For example structure storage can only be flattened as a whole memory block (any part of the structure flattened from other context will give assertion during structure processing). Same applies for the storage of pointers. Consider the below example:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">struct</span> type {
    <span class="pl-k">const</span> <span class="pl-k">char</span>* name;
    <span class="pl-k">unsigned</span> <span class="pl-k">long</span> v;
};

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(type,
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(name);
);

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">struct</span> type s = {<span class="pl-s"><span class="pl-pds">"</span>Some value here<span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>};

    <span class="pl-c1">FOR_ROOT_POINTER</span>((<span class="pl-k">unsigned</span> <span class="pl-k">short</span>*)&amp;s.<span class="pl-smi">v</span>,
        <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">unsigned</span> <span class="pl-k">short</span>,(<span class="pl-k">unsigned</span> <span class="pl-k">short</span>*)&amp;s.<span class="pl-smi">v</span>);
    );

    <span class="pl-c1">FOR_ROOT_POINTER</span>(&amp;s,
        <span class="pl-c1">FLATTEN_STRUCT</span>(type, &amp;s);
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/8-in_a
8-in_a: examples/8-in_a.c:12: flatten_struct_type: Assertion `__node-&gt;start==(uint64_t)_ptr' failed.
</code></pre>

<p>This will fail as part of the structure storage (2 bytes of the <code>v</code> field) has already been flattened and structure can only be flattened as a whole.<br>
Similar thing happens for pointers:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">const</span> <span class="pl-k">char</span>* st[<span class="pl-c1">2</span>] = {
            <span class="pl-s"><span class="pl-pds">"</span>Some value here<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>Other value here<span class="pl-pds">"</span></span>,
    };

    <span class="pl-c1">FOR_ROOT_POINTER</span>((<span class="pl-k">unsigned</span> <span class="pl-k">char</span>*)&amp;st[<span class="pl-c1">0</span>],
        <span class="pl-c1">FLATTEN_TYPE</span>(<span class="pl-k">unsigned</span> <span class="pl-k">char</span>, (<span class="pl-k">unsigned</span> <span class="pl-k">char</span>*)&amp;st[<span class="pl-c1">0</span>]);
    );

    <span class="pl-c1">FOR_ROOT_POINTER</span>(st,
        <span class="pl-c1">FOREACH_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, s, st, <span class="pl-c1">ptrarrmemlen</span>((<span class="pl-k">const</span> <span class="pl-k">void</span>* <span class="pl-k">const</span>*)st),
            <span class="pl-c1">FLATTEN_STRING</span>(s);
        );
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/8-in_b
8-in_b: libflat.c:406: get_pointer_node: Assertion `node-&gt;last&gt;=p+sizeof(void*)-1 &amp;&amp; "Invalid pointer address"' failed.
</code></pre>

<p>Here 1 byte of the <code>st[0]</code> pointer has already been flattened and therefore flattening the whole pointer fails.<br></p>

<p>Such situations (using part of structure/pointer storage in other contexts) are rare (and some might be considered bad practice) however they can happen (and sometimes there might be very good rationale to why to use them) therefore should be supported by Libflat seamlessly. There is actually no point why they wouldn't be supported (this derelict stems from initial library design and is no longer applicable) and will be supported in future releases of Libflat.<br></p>

<p><strong>5.</strong>  Libflat makes a copy of the original memory (i.e. bitwise copy) therefore flattening structures copies all the structure padding as well. This leads to the fact that after deserialization structure padding might be initialized differently as it would be if the structure had been initialized by compiler. This is reported by the Valgrind, however it's hard to imagine any other real-life consequences of this fact.<br></p>

<h2>
<a id="toubleshooting" class="anchor" href="#toubleshooting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Toubleshooting</h2>

<p>What to do when flattening fails? First thing to do is to check whether your use case falls into Libflat limitations (). If not there are more possible scenarios that breaks the plateau.<br></p>

<p>Consider the following example:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">struct</span> internal_type {
    <span class="pl-k">int</span> u:<span class="pl-c1">4</span>;
    <span class="pl-k">char</span> c;
};

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(internal_type);

<span class="pl-k">struct</span> type {
    <span class="pl-k">const</span> <span class="pl-k">char</span>* name;
    <span class="pl-k">unsigned</span> <span class="pl-k">long</span> v;
    <span class="pl-k">struct</span> type* next;
    <span class="pl-k">struct</span> internal_type* internal[<span class="pl-c1">4</span>];
};

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(type,
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(name);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(type, next);
    <span class="pl-en">AGGREGATE_FLATTEN_TYPE_ARRAY</span>(<span class="pl-k">struct</span> internal_type*, internal, <span class="pl-c1">4</span>);
    <span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">struct</span> internal_type*, p, ATTR(internal), 4,
        FLATTEN_STRUCT(internal_type, p);
    );
);

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">static</span> <span class="pl-k">struct</span> internal_type u = { .<span class="pl-smi">u</span>=<span class="pl-c1">1</span>, .<span class="pl-smi">c</span>=<span class="pl-s"><span class="pl-pds">'</span>#<span class="pl-pds">'</span></span> };

    <span class="pl-k">struct</span> type type_arr = { .<span class="pl-smi">name</span>=<span class="pl-s"><span class="pl-pds">"</span>type1<span class="pl-pds">"</span></span>, .<span class="pl-smi">v</span>=<span class="pl-c1">666</span>, &amp;type_arr, {&amp;u, &amp;u, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>}  };

    <span class="pl-c1">FOR_ROOT_POINTER</span>(&amp;type_arr,
        <span class="pl-c1">FLATTEN_STRUCT</span>(type, &amp;type_arr);
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<p>After running it you should get the following mysterious assertion:<br></p>

<pre><code>$ examples/8-in_c
8-in_c: libflat.c:257: fixup_set_insert: Assertion `(inode-&gt;ptr-&gt;node-&gt;start+inode-&gt;ptr-&gt;offset)==(ptr-&gt;node-&gt;start+ptr-&gt;offset) &amp;&amp; "Multiple pointer mismatch for the same storage"' failed.
</code></pre>

<p>This tells us that we have just flattened some memory location through a pointer but previously we flattened different memory location through the same pointer (i.e. the same pointer points to two different locations at the same time). How it's possible? Take a look more closely at the flattening recipes:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(type,
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(name);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(type, next);
    <span class="pl-en">AGGREGATE_FLATTEN_TYPE_ARRAY</span>(<span class="pl-k">struct</span> internal_type*, internal, <span class="pl-c1">4</span>);
    <span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">struct</span> internal_type*, p, ATTR(internal), 4,
        FLATTEN_STRUCT(internal_type, p);
    );
);</pre></div>

<p>Here we flatten whole structure <code>struct type</code> storage and its internal fields, i.e. <code>name, next, internal</code> pointer array and all the stuff the pointers from <code>internal</code> field points to. So where is the problem? It's actually quite difficult to grasp. The following line:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">AGGREGATE_FLATTEN_TYPE_ARRAY</span>(<span class="pl-k">struct</span> internal_type*, internal, <span class="pl-c1">4</span>);</pre></div>

<p>flattens storage of 4 pointers from the <code>internal</code> array but it's already been flattened when the structure storage got dumped! In other words, the <code>internal</code> table is a part of structure storage (it is embedded inside the structure, pointer by pointer) and the above line is superfluous. To see the exact cause notice that <code>internal</code> expands to the type pointer to <code>struct internal*</code>, storage for our 4 pointers has already been flattened (when encompassing structure storage has been flattened) but Libflat remembers that at offset corresponding to <code>internal</code> field we have a pointer to the internal structure storage (this is incorrect!). Later on when we flatten first <code>struct internal_type</code> Libflat got another pointer at the same offset which points to different location (static frame where <code>u</code> has been defined). After removing the superfluous line all works as expected:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(type,
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(name);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(type, next);
    <span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">struct</span> internal_type*, p, ATTR(internal), 4,
        FLATTEN_STRUCT(internal_type, p);
    );
);</pre></div>

<p>Another pitfall is to use root pointer which doesn't point to any location within flattened memory image:<br></p>

<div class="highlight highlight-source-c"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdio.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>assert.h<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>libflat.h<span class="pl-pds">"</span></span>

<span class="pl-k">int</span> <span class="pl-en">main</span>(<span class="pl-k">void</span>) {

    <span class="pl-c1">FILE</span>* out = <span class="pl-c1">fopen</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/memory.img<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>w<span class="pl-pds">"</span></span>);
    <span class="pl-c1">assert</span>(out);
    <span class="pl-c1">flatten_init</span>();

    <span class="pl-k">const</span> <span class="pl-k">char</span>* s = <span class="pl-s"><span class="pl-pds">"</span>Very valuable data<span class="pl-pds">"</span></span>;

    <span class="pl-c1">FOR_ROOT_POINTER</span>(&amp;s,
        <span class="pl-c1">FLATTEN_STRING</span>(s);
    );

    <span class="pl-c1">assert</span>(<span class="pl-c1">flatten_write</span>(out) == <span class="pl-c1">0</span>);

    <span class="pl-c1">flatten_fini</span>();
    <span class="pl-c1">fclose</span>(out);

    <span class="pl-k">return</span> <span class="pl-c1">0</span>;
}</pre></div>

<pre><code>$ examples/8-in_d
8-in_d: libflat.c:530: flatten_write: Assertion `node!=0' failed.
</code></pre>

<p>Here the only actually flattened memory region is for the string storage area (19 bytes). Therefore root pointer which points to the address of first byte of the string is not included in the final memory image. To fix it replace flattening recipe by:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FOR_ROOT_POINTER</span>(s,
    <span class="pl-en">FLATTEN_STRING</span>(s);
);</pre></div>

<p>or include the pointer address in the flattened memory image:<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FOR_ROOT_POINTER</span>(&amp;s,
    <span class="pl-en">FOR_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, v, &amp;s,
        <span class="pl-en">FLATTEN_STRING</span>(v);
    );
);</pre></div>

<h2>
<a id="contribution" class="anchor" href="#contribution" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Contribution</h2>

<p>There are number of ideas how to improve the Libflat. Some ideas are listed below.<br></p>

<ol>
<li>Currently Libflat works on Linux and Windows (x86/x64 architecture). Port to ARM/ARM64 (Android) would be very appreciated.<br>
</li>
<li>All Libflat examples has been tested on Linux. It would be appreciated to prepare Visual Studio project and test all examples on Windows.<br>
</li>
<li>No tests has been done with C unions and adding such tests would be appreciated.<br>
</li>
<li>Fixing limited structure/pointer overlays (see: <a href="#limit4">limitations/4</a>).<br>
</li>
<li>Adding root pointer to flattened memory image if not present (see troubleshooting).<br>
</li>
<li>Currently Libflat doesn't support flattening pointers to functions. This functionality would be implemented using dynamic linker capabilities (dladdr on Linux and Windows equivalent) by translating function addresses to corresponding symbols and storing it in the final memory image.<br>
</li>
<li>Currently Libflat API only allows to save entire memory image to single file. Consider enhancing the API to allow for creating and returning multiple flattened memory images for selected recipes.<br>
</li>
<li>Currently there is no support for C++ classes (only C++ POD types can be flattened). Design and implementation of flattening and reconstructing C++ classes would be appreciated (unfortunately it seems impossible to do this in C++ standard way and taking advantage of platform/compilator dependent functionalities would probably be needed).<br>
</li>
<li>Enable proper error handling instead of rough assertions.<br>
</li>
<li>Overcoming problems with free/reallocations in the unflattened memory image (see limitations/3).<br>
</li>
<li>More tests, error reports and bug fixes.<br>
</li>
</ol>

<h2>
<a id="final-word" class="anchor" href="#final-word" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Final word</h2>

<p>To conclude all thoughts let's get back to the serializing GNU Make internal data structures. The question was whether we can omit the parsing phase at all and read in the whole memory content ready for going (or almost ready)? First version of Libflat was specifically created for that task. The main data structure of GNU Make internals is the <code>struct file</code> structure. It's opaque structure that branches and links with other <code>struct file</code> structues into the dependency graph. Other important structures are <code>struct hash_table</code> and <code>struct rule</code> among others.<br></p>

<p>The following recipes has been created for the internal Make structures (three most complicated data structures has been selected here):<br></p>

<div class="highlight highlight-source-c"><pre><span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(file,
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(name);
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(hname);
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(vpath);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(dep, deps);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(commands, cmds);
    <span class="pl-en">AGGREGATE_FLATTEN_STRING</span>(stem);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(dep, also_make);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(file, prev);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(file, last);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(file, renamed);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(variable_set_list, variables);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(variable_set_list, pat_variables);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(file, parent);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(file, double_colon);
);

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(hash_table,
    <span class="pl-en">AGGREGATE_FLATTEN_TYPE_ARRAY</span>(<span class="pl-k">void</span>*, ht_vec, ATTR(ht_size));
    <span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">void</span>*, p, ATTR(ht_vec), ATTR(ht_size),
        if (!HASH_VACANT (p)) FLATTEN_STRUCT(file, p);
    );
);

<span class="pl-en">FUNCTION_DEFINE_FLATTEN_STRUCT</span>(rule,
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(rule, next);
    <span class="pl-en">AGGREGATE_FLATTEN_TYPE_ARRAY</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, targets, ATTR(num));
    <span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, p, ATTR(targets), ATTR(num),
        FLATTEN_STRING(p);
    );
    <span class="pl-en">AGGREGATE_FLATTEN_TYPE_ARRAY</span>(<span class="pl-k">unsigned</span> <span class="pl-k">int</span>, lens,ATTR(num));
    <span class="pl-en">AGGREGATE_FLATTEN_TYPE_ARRAY</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, suffixes, ATTR(num));
    <span class="pl-en">FOREACH_POINTER</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, p, ATTR(suffixes), ATTR(num),
        FLATTEN_STRING(p);
    );
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(dep, deps);
    <span class="pl-en">AGGREGATE_FLATTEN_STRUCT</span>(commands, cmds);
);</pre></div>

<p>After other amendments (pointer for functions for hash tables needed to be re-initialized among other things) internal GNU Make image has been created and saved:<br></p>

<pre><code>$ time make -M.cachefull
============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=6.0
TARGET_PRODUCT=aosp_arm64
TARGET_BUILD_VARIANT=eng
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm64
TARGET_ARCH_VARIANT=armv8-a
TARGET_CPU_VARIANT=generic
TARGET_2ND_ARCH=arm
TARGET_2ND_ARCH_VARIANT=armv7-a-neon
TARGET_2ND_CPU_VARIANT=cortex-a15
HOST_ARCH=x86_64
HOST_OS=linux
HOST_OS_EXTRA=Linux-3.13.0-58-generic-x86_64-with-Ubuntu-14.04-trusty
HOST_BUILD_TYPE=release
BUILD_ID=MRA58K
OUT_DIR=out
============================================
including ./abi/cpp/Android.mk ...
including ./art/Android.mk ...
including ./bionic/Android.mk ...
...
including ./system/security/softkeymaster/Android.mk ...
including ./system/vold/Android.mk ...
including ./tools/external/fat32lib/Android.mk ...

# Flattening done. Summary:
  Memory size: 467750822 bytes
  Linked 13075800 pointers
  Written 572357358 bytes

real    1m26.891s
user    0m45.526s
sys 0m39.327s
</code></pre>

<p>Finally reading-in internal GNU Make data structures with warm caches and fully built binaries (incremental build without changes) concludes the journey:<br></p>

<pre><code>$ time make -c.cachefull
# Unflattening done. Summary:
  Image read time: 0,101719s
  Fixing memory time: 0,033349s
  Total time: 0,135113s
  Total bytes read: 572357358
make: Nothing to be done for 'droid'.

real    0m0.662s
user    0m0.465s
sys 0m0.200s
</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/braton/libflat">Libflat</a> is maintained by <a href="https://github.com/braton">braton</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-73729732-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
