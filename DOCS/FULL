@ Introduction

Libflat is a library for fast serialization of C/C++ structures. Its main goal is speed (and of course correctness). Most of the time when you serialize your data the speed doesn't matter (in contrast to other factors like simplicity, good coverage etc.). But there are some cases when the speed is crucial, i.e. you're working with some big data sets and you need to serialize/deserialize them often (you might have some H/W device that produces a mass od data and you want to read in and process this data on another machine).

In standard approach for serialization you pick up or design some protocol, choose low-level medium (like JSON) and write the logic to save your structures. On the other side of the mirror you read in the packets, figure out what they represent and combine them to recreate your beloved data. This is fine. Everybody do that. This works well. Unfortunately sometimes this works slow (rarely though and most of the times you can get away with it). Libflat is about to make this process as fast as possible by all cost. If you need this sort of speed standard you might want to check this out.

Good example for using Libflat is Android build system (still based on Makefile build system as of Feb. 2016). Androd build system is monolithic which makes it extremely parallelizable. The main obstacle though is that you need to read all the makefiles up front (and there is lots of them). Trying it with hot caches gives the following (tests for android-6.0.0_r5)

------------------------------------------------
$ source build/envsetup.sh
$ lunch aosp_arm64-eng
$ time make
============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=6.0
TARGET_PRODUCT=aosp_arm64
TARGET_BUILD_VARIANT=eng
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm64
TARGET_ARCH_VARIANT=armv8-a
TARGET_CPU_VARIANT=generic
TARGET_2ND_ARCH=arm
TARGET_2ND_ARCH_VARIANT=armv7-a-neon
TARGET_2ND_CPU_VARIANT=cortex-a15
HOST_ARCH=x86_64
HOST_OS=linux
HOST_OS_EXTRA=Linux-3.13.0-58-generic-x86_64-with-Ubuntu-14.04-trusty
HOST_BUILD_TYPE=release
BUILD_ID=MRA58K
OUT_DIR=out
============================================
including ./abi/cpp/Android.mk ...
including ./art/Android.mk ...
including ./bionic/Android.mk ...
...
including ./system/security/softkeymaster/Android.mk ...
including ./system/vold/Android.mk ...
including ./tools/external/fat32lib/Android.mk ...
------------------------------------------------

Summary:
------------------------------------------------
real	0m41.977s
user	0m32.590s
sys		0m9.654s
------------------------------------------------

Not so bad, especially when you have lots of RAM (so the only job that needs to be done is to parse all the Makefiles in memory using one thread). But what if we can omit the parsing phase at all and read in the whole memory content ready for going (or almost ready)?


@ How Libflat works

Libflat works by making copy of the process memory for indicated variables and structures. It doesn't matter whether original storage is automatic, static or allocated. The result is always stored on the heap (and kept on the heap after deserialization). Memory image is flat, i.e. whole copied memory image has continuous addresses. Pointers to original memory locations are properly resolved in the flattened image. Having whole memory serialized into one continuous memory block makes deserialization very fast (it is just a matter of reading entire block from disk to memory). Pointer resolution phase is needed after image is read in but this has linear complexity with number of pointers.

Simplest possible case of serialization can be made for automatic int variable as follows:

#include <stdio.h>
#include <assert.h>
#include "libflat.h"

int main(void) {

	FILE* out = fopen("/tmp/memory.img", "w");
	assert(out);
	flatten_init();

	int automatic = 0xDABBAD00;

	FOR_ROOT_POINTER(&automatic,
		FLATTEN_TYPE(int,&automatic);
	);

	assert(flatten_write(out) == 0);

	flatten_fini();
	fclose(out);

	return 0;
}

------------------------------------------------
$ examples/1-in
# Flattening done. Summary:
  Memory size: 4 bytes
  Linked 0 pointers
  Written 44 bytes
------------------------------------------------


On the other side reading the stored value can be now done by:

#include <stdio.h>
#include <assert.h>
#include "libflat.h"

int main(void) {

	FILE* in = fopen("/tmp/memory.img", "r");
	assert(in);
	unflatten_init();

	assert(unflatten_read(in) == 0);

	int* now_allocated = ROOT_POINTER_NEXT(int*);
	printf("%08X\n", *now_allocated);

	unflatten_fini();
	fclose(in);

	return 0;
}

------------------------------------------------
$ examples/1-out
# Unflattening done. Summary:
  Image read time: 0.000036s
  Fixing memory time: 0.000000s
  Total time: 0.000063s
  Total bytes read: 44
DABBAD00
------------------------------------------------

Similar procedure can be done with arrays and strings as in the below examples:

#include <stdio.h>
#include <assert.h>
#include <stdint.h>
#include "libflat.h"

int main(void) {

	FILE* out = fopen("/tmp/memory.img", "w");
	assert(out);
	flatten_init();

	int i;
	const char* s = "Fibonacci would not calculate this as fast";
	long fib[40] = { 0, 1 };
	for (i = 2; i < 40; ++i)
		fib[i] = fib[i - 1] + fib[i - 2];

	FOR_ROOT_POINTER(fib,
		FLATTEN_TYPE_ARRAY(long,fib,40);
	);

	FOR_ROOT_POINTER(s,
		FLATTEN_STRING(s);
	);

	assert(flatten_write(out) == 0);

	flatten_fini();
	fclose(out);

	return 0;
}

------------------------------------------------
$ examples/2-in
# Flattening done. Summary:
  Memory size: 363 bytes
  Linked 0 pointers
  Written 411 bytes
  ------------------------------------------------

#include <stdio.h>
#include <assert.h>
#include <stdint.h>
#include "libflat.h"

int main(void) {

	FILE* in = fopen("/tmp/memory.img", "r");
	assert(in);
	unflatten_init();

	assert(unflatten_read(in) == 0);

	long* fib = ROOT_POINTER_SEQ(long*, 0);
	const char* s = ROOT_POINTER_SEQ(const char*, 1);

	int i;
	for (i = 0; i < 40; ++i)
		printf("%ld ", fib[i]);
	printf("\n");
	printf("%s\n", s);

	unflatten_fini();
	fclose(in);

	return 0;
}

------------------------------------------------
$ examples/2-out
# Unflattening done. Summary:
  Image read time: 0.000055s
  Fixing memory time: 0.000000s
  Total time: 0.000100s
  Total bytes read: 411
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 
Fibonacci would not calculate this as fast
------------------------------------------------

This brings the notion of the so called root pointer. When you read the contents of memory you will have a block of data to your disposal. But how to access it? You need some pointer to any part of this memory (assuming you can interpret the memory from this point and link to other parts). This is what the root pointer is for. It is just a pointer to some part of unflatten memory. This has its own storage and is not part of the memory image (but of course it is part of the image file).

Let's back to our first example. 

int automatic = 0xDABBAD00;

FOR_ROOT_POINTER(&automatic,
	FLATTEN_TYPE(int,&automatic);
);

We simply told our flattener engine that we want to access the memory through the address of the "automatic" variable (i.e. we will hold it reference). Check out that flattened memory size is 4 c-bytes (which happens to be the sizeof(int) on my example making machine). But it doesn't need to be this way. We can modify the first example slightly and specify the root pointer address through some other pointer variable:

int automatic = 0xDABBAD00;
int * pi = &automatic;

FOR_ROOT_POINTER(pi,
	FLATTEN_TYPE(int,&automatic);
);

After image read we just assign this value to our own defined variable as below:

int* now_allocated = ROOT_POINTER_NEXT(int*);

You might have several root pointers to several parts of unflatten memory. To access them you simply call ROOT_POINTER_NEXT with proper type sequentially to receive one root pointer after another (you will get them in the order you did issue FOR_ROOT_POINTER macro in the first place). You can also retrieve root pointers as below:

const char* s = ROOT_POINTER_SEQ(const char*,1);

This will read the second (with index 1) root pointer stored while creating memory image.

As you might have noticed in order to flatten some type you will need a pointer to it. But what about pointers (or pointers to pointers etc.)? There is no difference as long as you have a pointer to it (or pointer to pointer to it). Huh?

#include <stdio.h>
#include <assert.h>
#include "libflat.h"

int main(void) {

	FILE* out = fopen("/tmp/memory.img", "w");
	assert(out);
	flatten_init();

	double magic_number = 3.14159265359;
	double* pointer_to_it = &magic_number;
	double** pointer_to_pointer_to_it = &pointer_to_it;
	double*** ehhh = &pointer_to_pointer_to_it;

	FOR_ROOT_POINTER(ehhh,
		FLATTEN_TYPE(double**,&pointer_to_pointer_to_it);
		FOR_POINTER(double**,p,&pointer_to_pointer_to_it,
			FLATTEN_TYPE(double*,p);
			FOR_POINTER(double*,q,p,
				FLATTEN_TYPE(double,q);
			);
		);
	);

	assert(flatten_write(out) == 0);

	flatten_fini();
	fclose(out);

	return 0;
}

------------------------------------------------
$ examples/3-in
# Flattening done. Summary:
  Memory size: 24 bytes
  Linked 2 pointers
  Written 80 bytes
------------------------------------------------

You have just written three values into memory (two pointers and one double value). How so?

The line:

FLATTEN_TYPE(double**,&pointer_to_pointer_to_it);

writes the value pointed to by "&pointer_to_pointer_to_it" which is of type double** (this is the actual value stored in the "pointer_to_pointer_to_it" pointer). We did exactly the same in the first example:

FLATTEN_TYPE(int,&automatic);

We wrote the value pointed to by "&automatic" which was of type int.

Next line:

FOR_POINTER(double**,p,&pointer_to_pointer_to_it,...);

takes the actual value pointed to by "&pointer_to_pointer_to_it" and stores it in newly created variable "p" of appropriate type (double**). This variable must be pointer hence the macro name. New variable "p" (you can actually give it any accessible name) can be used in the block of code that follows ("..." macro arguments).

The following code we does the same trick, i.e. writes the value pointed by p (of type double*):

FLATTEN_TYPE(double*,p);

Finally we create another variable "q" that acquires the value pointed by "p" (which finally points to the magic double value) and writes the double number to the memory image:

FOR_POINTER(double*,q,p,
	FLATTEN_TYPE(double,q);
);

Checking the stored value confirms our words:

#include <stdio.h>
#include <assert.h>
#include <stdint.h>
#include "libflat.h"

int main(void) {

	FILE* in = fopen("/tmp/memory.img", "r");
	assert(in);
	unflatten_init();

	assert(unflatten_read(in) == 0);

	double*** ehhh = ROOT_POINTER_SEQ(double***, 0);
	printf("The magic answer to the ultimate question of life?: %f\n", ***ehhh);

	unflatten_fini();
	fclose(in);

	return 0;
}

------------------------------------------------
$ examples/3-out
# Unflattening done. Summary:
  Image read time: 0.000058s
  Fixing memory time: 0.000001s
  Total time: 0.000105s
  Total bytes read: 80
The magic answer to the ultimate question of life?: 3.141593
------------------------------------------------

In the write output you can now see the line that says:

------------------------------------------------
Linked 2 pointers
------------------------------------------------

The memory image contained two pointers as we just explained. But after reading them in in the second process (which could actually happened on different computer on diffrenent continent) the pointer values would not probably have any proper meaning in the context of new process address space. That's why we need to fix them.

Consider the following block of code:

#include <stdio.h>
#include <assert.h>
#include "libflat.h"

int main(void) {

	FILE* out = fopen("/tmp/memory.img", "w");
	assert(out);
	flatten_init();

	static char carr[] = "You don't need to be great to start, "
			"but you need to start to be great";

	const char* start = carr;
	const char* middle = carr + 41;

	FOR_ROOT_POINTER(start,
		FLATTEN_TYPE(const char*,&start);
		FOR_POINTER(const char*,s,&start,
			FLATTEN_STRING(s);
		);
	);

	FOR_ROOT_POINTER(middle,
		FLATTEN_TYPE(const char*,&middle);
		FOR_POINTER(const char*,s,&middle,
			FLATTEN_STRING(s);
		);
	);

	printf("&carr[0]: %p\n", &carr[0]);
	printf("&start: %p -> %p\n", &start, start);
	printf("&middle: %p -> %p\n", &middle, middle);

	assert(flatten_write(out) == 0);

	flatten_fini();
	fclose(out);

	return 0;
}

And the result of running it:

------------------------------------------------
$ examples/4-in
&carr[0]: 0x6020c0
&start: 0x7fff9da3a8c0 -> 0x6020c0
&middle: 0x7fff9da3a8c8 -> 0x6020e9
# Flattening done. Summary:
  Memory size: 87 bytes
  Linked 2 pointers
  Written 151 bytes
------------------------------------------------

The original memory looks as follows:

Somewhere in the static memory area:
0x6020c0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0]
								 ^
								 0x6020e9
Somewhere on the stack:
0x7fff9da3a8c0: [0x6020c0|0x6020e9]

Libflat will arrange memory image in ascending order of original addresses:

[Y|o|u|...|g|r|e|a|t|0|0x6020c0|0x6020e9]

and replace original pointer values with its position independent counterparts (independent from the starting address of the memory image in the process address space):

[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029]
 ^					   ^
 0x000000			   0x000029

It also needs to store two additional values, i.e. at which offset in the flattened memory area actual pointers appears (as we need to find them later):

[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f]
 											 ^	   	  ^
 											 0x47	  0x4f

Finally it also stores two root pointers (start and middle pointer values) as the offsets in the flattened memory image for later retrieval:

[Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f] [0x47,0x4f]
																			 ^	  ^
																			 start offset
																			 	  ^
																				  middle offset

In this example we have only two pointers and both of them are root pointers therefore stored values are duplicated. In real life scenarios we will probably have much more standard pointers and very few root pointers (as all must be manually setup by programmer).


During unflattening stage (as in the below example) several things happen.

#include <stdio.h>
#include <assert.h>
#include <stdint.h>
#include "libflat.h"

int main(void) {

	FILE* in = fopen("/tmp/memory.img", "r");
	assert(in);
	unflatten_init();

	assert(unflatten_read(in) == 0);

	const char* start = ROOT_POINTER_SEQ(const char*, 0);
	const char* middle = ROOT_POINTER_SEQ(const char*, 1);

	printf("&start: %p -> %p\n", &start, start);
	printf("&middle: %p -> %p\n", &middle, middle);
	const void* ptr1 = start + strlen(start) + 1;
	printf("*(%p) => %p\n", ptr1, *(void**) ptr1);
	const void* ptr2 = start + strlen(start) + 1 + sizeof(const char*);
	printf("*(%p) => %p\n", ptr2, *(void**) ptr2);
	printf("%s\n", start);
	printf("Remember: %s\n", middle);

	unflatten_fini();
	fclose(in);

	return 0;
}

------------------------------------------------
$ examples/4-out
# Unflattening done. Summary:
  Image read time: 0.000037s
  Fixing memory time: 0.000001s
  Total time: 0.000068s
  Total bytes read: 151
&start: 0x7ffe7454eae0 -> 0x8de2a0
&middle: 0x7ffe7454eae8 -> 0x8de2c9
*(0x8de2e7) => 0x8de2a0
*(0x8de2ef) => 0x8de2c9
You don't need to be great to start, but you need to start to be great
Remember: you need to start to be great
------------------------------------------------

New memory area is created in the allocated storage area (the heap) and memory image is read in:

0x8de2a0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x000000|0x000029] [0x47,0x4f] [0x47,0x4f]
								 ^
								 0x8de2c9

Now we read two pointer offsets (0x47 and 0x4f) and fix two pointers at these offsets by adding the initial address of the allocated memory area to the position independent pointer value:

0x8de2a0: [Y|o|u| |d|...|b|u|t| |y|o|u|...|g|r|e|a|t|0|0x8de2a0|0x8de2c9] [0x47,0x4f] [0x47,0x4f]
								 ^					   ^		^		  ^ pointer offset array
								 0x8de2c9			   0x47		0x4f				   ^
								 					   ^		^					   root pointer offset array
								 					   0x8de2e7 0x8de2ef

Now the first pointer points at the beginning of the string and second points in the middle. This process is called linking and this is what the line "Linked 2 pointers" was talking about.

Finally we read two root pointers at offset location 0x47 and 0x4f which happens to be the same values as the only two pointers, create their storage and set the translated values:

&start: 0x7ffe7454eae0 -> 0x8de2a0
&middle: 0x7ffe7454eae8 -> 0x8de2c9

To finally confirm the example we will move start pointer (and the second pointer) by the length of the string and read the value stored at the resulting location:

const void* ptr1 = start+strlen(start)+1;
printf("*(%p) => %p\n",ptr1,*(void**)ptr1);
const void* ptr2 = start+strlen(start)+1+sizeof(const char*);
printf("*(%p) => %p\n",ptr2,*(void**)ptr2);

------------------------------------------------
*(0x8de2e7) => 0x8de2a0
*(0x8de2ef) => 0x8de2c9
------------------------------------------------

There is actually more you can do with pointers. For instance you can manage arrays of pointers in similar fashion:

#include <stdio.h>
#include <assert.h>
#include "libflat.h"

int main(void) {

	FILE* out = fopen("/tmp/memory.img", "w");
	assert(out);
	flatten_init();

	const char* argv[] = { "Program name", "Argument 0", "Argument 1",
			"Argument 2", "Argument 3", 0 };

	FOR_ROOT_POINTER(argv,
		FOREACH_POINTER(const char*,arg,argv,
				ptrarrmemlen((const void * const*)argv),
			FLATTEN_TYPE(const char*,arg);
			FLATTEN_STRING(arg);
		);
	);

	assert(flatten_write(out) == 0);

	flatten_fini();
	fclose(out);

	return 0;
}

------------------------------------------------
$ examples/5-in
# Flattening done. Summary:
  Memory size: 105 bytes
  Linked 5 pointers
  Written 185 bytes
------------------------------------------------

Here, for each pointer in the array "argv" we create temporary variable "arg" of type "const char*" which we can use in the subsequent block of code. We must specify the size of the array. We might know it in advance or we can compute it in real time. In case of arrays terminated with pointer 0 (NULL pointer) there is function "ptrarrmemlen" available for this purpose. It simply iterates through entire pointer array and counts the pointers until it reaches the pointer 0 (and counts it as well). Similar function is used internally by the FLATTEN_STRING macro, i.e. "strmemlen" function which returns the length of string including NULL terminating 0 value.

In the code body we first flatten the pointer itself and then we flatten the string pointed to by it.

#include <stdio.h>
#include <assert.h>
#include <stdint.h>
#include "libflat.h"

int main(void) {

	FILE* in = fopen("/tmp/memory.img", "r");
	assert(in);
	unflatten_init();

	assert(unflatten_read(in) == 0);

	const char** argv = ROOT_POINTER_NEXT(const char**);
	while (*argv) {
		printf("%s\n", *argv);
		argv++;
	}

	unflatten_fini();
	fclose(in);

	return 0;
}

------------------------------------------------
$ examples/5-out
# Unflattening done. Summary:
  Image read time: 0.000057s
  Fixing memory time: 0.000001s
  Total time: 0.000104s
  Total bytes read: 185
Program name
Argument 0
Argument 1
Argument 2
Argument 3
------------------------------------------------

We finally came to the last (and most interesting) part where all the fun really begins, i.e. flattening C structures. Flattening C structure is as simple as:

FLATTEN_STRUCT(type,pointer);

However you have to provide recipe how to actually flatten structure internal fields. In the below example we want to flatten structure "figure" (which happens to be a square):

#include <stdio.h>
#include <assert.h>
#include "libflat.h"

struct point {
	double x;
	double y;
};

struct edge {
	struct point p[2];
	struct edge* e;
};

struct figure {
	const char* name;
	struct edge* e;
};

FUNCTION_DEFINE_FLATTEN_STRUCT(figure);

int main(void) {

	FILE* out = fopen("/tmp/memory.img", "w");
	assert(out);
	flatten_init();

	struct point sqv[4] = {{1.0,1.0},{1.0,-1.0},{-1.0,-1.0},{-1.0,1.0}};
	struct edge sqe[4] = {
			{ {sqv[0],sqv[1]}, &sqe[1] },
			{ {sqv[1],sqv[2]}, &sqe[2] },
			{ {sqv[2],sqv[3]}, &sqe[3] },
			{ {sqv[3],sqv[0]}, &sqe[0] }
	};

	struct figure square = { "square", sqe };

	printf("sizeof(struct figure): %zu\n", sizeof(struct figure));

	FOR_ROOT_POINTER(&square,
		FLATTEN_STRUCT(figure,&square);
	);

	assert(flatten_write(out) == 0);

	flatten_fini();
	fclose(out);

	return 0;
}

------------------------------------------------
$ examples/6-in_a
sizeof(struct figure): 16
# Flattening done. Summary:
  Memory size: 16 bytes
  Linked 0 pointers
  Written 56 bytes
------------------------------------------------

As we can see the structure has been actually flattened but quick glance reveals that not everything might have gone as expected. We have just written 16 bytes (the size of the structure) itself but no internal fields has been touched (and they will point to the vain after reading them out).

The function providing the recipe how to flatten internal structure fields is called FUNCTION_DEFINE_FLATTEN_STRUCT. We should provide the type of the structure and the code responsible for writing structure content. Let's workout the example a little more and add the following functions:

FUNCTION_DEFINE_FLATTEN_STRUCT(edge,
	AGGREGATE_FLATTEN_STRUCT(edge,e);
);

FUNCTION_DEFINE_FLATTEN_STRUCT(figure,
	AGGREGATE_FLATTEN_STRING(name);
	AGGREGATE_FLATTEN_STRUCT(edge,e);
);

------------------------------------------------
$ examples/6-in_b
sizeof(struct figure): 16
# Flattening done. Summary:
  Memory size: 183 bytes
  Linked 6 pointers
  Written 271 bytes
------------------------------------------------

Voila! By adding several lines of code we managed to write down the whole figure properly resolving all pointers along the way. 

So far we have seen several functions for writing memory image, i.e.:

FLATTEN_STRING(pointer)
FLATTEN_TYPE(type,pointer)
FLATTEN_TYPE_ARRAY(type,pointer,size)
FLATTEN_STRUCT(type,pointer)

There is one more function we can use to save memory structures:

FLATTEN_STRUCT_ARRAY(type,pointer,size)

It's actually a convenience function that takes the burden of serializing a structure array pointer by pointer off from the user. It is needed to bring the following definition when using it:

INLINE_FUNCTION_DEFINE_FLATTEN_STRUCT_ARRAY(type)

Each of these five functions has so called AGGREGATE counterparts, i.e.:

AGGREGATE_FLATTEN_STRING(field)
AGGREGATE_FLATTEN_TYPE(type,field)
AGGREGATE_FLATTEN_TYPE_ARRAY(type,field,size)
AGGREGATE_FLATTEN_STRUCT(type,field)
AGGREGATE_FLATTEN_STRUCT_ARRAY(type,field,size)

Instead of pointer to variable we use the corresponding field name from within the structure.

If we want to use the field name itself for other purpose (i.e. length of the array for some other structure field) we have available macro:

ATTR(field)

Finally to bring the structure flattening functions declarations across translation units we can use macro:

FUNCTION_DECLARE_FLATTEN_STRUCT(type)

Please note that in the above example we didn't write function recipe for flattening the "struct point". We also omitted field "p" from the "struct edge". These values are part of internal structure storage (they are not pointers) therefore there's no need for recursive resolution of those fields (they will be flattened together with the original structure storage).

Reading up the square structure from memory image is straightforward:

#include <stdio.h>
#include <assert.h>
#include <stdint.h>
#include <math.h>
#include "libflat.h"

struct point {
	double x;
	double y;
};

struct edge {
	struct point p[2];
	struct edge* e;
};

struct figure {
	const char* name;
	struct edge* e;
};

int main(void) {

	FILE* in = fopen("/tmp/memory.img", "r");
	assert(in);
	unflatten_init();

	assert(unflatten_read(in) == 0);

	const struct figure* square = ROOT_POINTER_NEXT(const struct figure*);

	struct edge* e = square->e;
	double circumference = 0;
	do {
		circumference += sqrt(
				pow(e->p[0].x - e->p[1].x, 2) + pow(e->p[0].y - e->p[1].y, 2));
		e = e->e;
	} while (e != square->e);

	printf("%s circumference: %f\n", square->name, circumference);

	unflatten_fini();
	fclose(in);

	return 0;
}

------------------------------------------------
$ examples/6-out
# Unflattening done. Summary:
  Image read time: 0.000051s
  Fixing memory time: 0.000001s
  Total time: 0.000095s
  Total bytes read: 271
square circumference: 8.000000
------------------------------------------------

It would be also possible to flatten the entire structure with all links using mere pointer flattening functions but in that case we would need to implement the recursive structure member resolution by ourselves:

#include <stdio.h>
#include <assert.h>
#include "libflat.h"

struct point {
	double x;
	double y;
};

struct edge {
	struct point p[2];
	struct edge* e;
};

struct figure {
	const char* name;
	struct edge* e;
};

int main(void) {

	FILE* out = fopen("/tmp/memory.img", "w");
	assert(out);
	flatten_init();

	struct point sqv[4] = {{1.0,1.0},{1.0,-1.0},{-1.0,-1.0},{-1.0,1.0}};
	struct edge sqe[4] = {
			{ {sqv[0],sqv[1]}, &sqe[1] },
			{ {sqv[1],sqv[2]}, &sqe[2] },
			{ {sqv[2],sqv[3]}, &sqe[3] },
			{ {sqv[3],sqv[0]}, &sqe[0] }
	};

	struct figure square = { "square", sqe };

	printf("sizeof(struct figure): %zu\n", sizeof(struct figure));

	FOR_ROOT_POINTER(&square,
		FOR_POINTER(const char*,n,&square.name,
			FLATTEN_STRING(n);
		);
		FOR_POINTER(const char*,n,&square.e,
			FLATTEN_TYPE(struct edge*,n);
		);
		struct edge* e = square.e;
		do {
			FOR_POINTER(struct edge*,pe,&e->e,
				FLATTEN_TYPE_ARRAY(struct point,pe->p,2);
				FLATTEN_TYPE(struct edge*,pe);
			);
			e = e->e;
		} while(e!=square.e);
	);

	assert(flatten_write(out) == 0);

	flatten_fini();
	fclose(out);

	return 0;
}

------------------------------------------------
$ examples/6-in_c
sizeof(struct figure): 16
# Flattening done. Summary:
  Memory size: 183 bytes
  Linked 6 pointers
  Written 271 bytes
------------------------------------------------

In the final example we will try to pressure the library a little bit and notice how it responds to more demanding job. Let's modify the previous example and try to approximate a circle. To avoid stack overflow (in the previous example walking through the edges during flattening stage required one recursive call deeper per each edge) we will modify the structures slightly. "struct figure" will hold a table of all points and each point will hold a pointer to each other point in the polygon. We will build regular polygon with points around the circle circumference of radius 1. When number of points is 8 it would look something like below:

<PICTURE/>

We will describe the flattening recipe for each structure as in the full example below:

#include <stdio.h>
#include <assert.h>
#include <math.h>
#include "libflat.h"

struct point {
	double x;
	double y;
	unsigned n;
	struct point** other;
};

FUNCTION_DEFINE_FLATTEN_STRUCT(point,
	AGGREGATE_FLATTEN_TYPE_ARRAY(struct point*,other,ATTR(n));
	FOREACH_POINTER(struct point*,p,ATTR(other),ATTR(n),
			FLATTEN_STRUCT(point,p);
	);
);

struct figure {
	const char* name;
	unsigned n;
	struct point* points;
};

FUNCTION_DEFINE_FLATTEN_STRUCT(figure,
	AGGREGATE_FLATTEN_STRING(name);
	AGGREGATE_FLATTEN_STRUCT_ARRAY(point,points,ATTR(n));
);

int main(int argc, char** argv) {

	FILE* out = fopen("/tmp/memory.img", "w");
	assert(out);
	flatten_init();

	assert(argc > 1);
	struct figure circle = { "circle" };
	assert(sscanf(argv[1], "%u", &circle.n) == 1);
	assert(circle.n > 1);
	circle.points = calloc(circle.n, sizeof(struct point));
	assert(circle.points);
	double radius = 1.0, angle = 2 * M_PI / circle.n;

#define MAKE_POINT(p,i,N)	\
	p.x = cos(angle*(radius*(i)));	\
	p.y = sin(angle*(radius*(i)));	\
	p.n = (N);	\
	p.other = calloc((N),sizeof*p.other);	\
	assert(p.other);

	unsigned i, j;
	for (i = 0; i < circle.n; ++i) {
		MAKE_POINT(circle.points[i], i, circle.n - 1);
	}
	for (i = 0; i < circle.n; ++i) {
		unsigned u = 0;
		for (j = 0; j < circle.n; ++j) {
			if (i == j)
				continue;
			circle.points[i].other[u++] = &circle.points[j];
		}
	}

	FOR_ROOT_POINTER(&circle,
		FLATTEN_STRUCT(figure,&circle);
	);

	for (i = 0; i < circle.n; ++i) {
		free(circle.points[i].other);
	}
	free(circle.points);

	assert(flatten_write(out) == 0);

	flatten_fini();
	fclose(out);

	return 0;
}

The example code allows us to specify the number of points we want to process, e.g.:

------------------------------------------------
$ examples/circular-in 8
------------------------------------------------

Depending on the size of available memory (and available disk space and time) we might set the value accordingly. For the following value we have got:

------------------------------------------------
$ examples/circular-in 10000
# Flattening done. Summary:
  Memory size: 800240031 bytes
  Linked 100000002 pointers
  Written 1600240087 bytes
------------------------------------------------

On the other side we will now read the entire image and try to calculate several properties of our close to circle polygon. These would be number of edges, sum of lengths of edges and diagonals and finally the approximated circumference (in the example we will walk through all the points and count the edges/diagonals and their lengths; after walking from point A to point B we will break the connection between B and A (by setting the B pointer to 0)):


#include <stdio.h>
#include <assert.h>
#include <stdint.h>
#include <math.h>
#include "libflat.h"

struct point {
	double x;
	double y;
	unsigned n;
	struct point** other;
};

struct figure {
	const char* name;
	unsigned n;
	struct point* points;
};

int main(void) {

	FILE* in = fopen("/tmp/memory.img", "r");
	assert(in);
	unflatten_init();

	assert(unflatten_read(in) == 0);

	const struct figure* circle = ROOT_POINTER_NEXT(const struct figure*);

	unsigned i, j;
	double length = 0, circumference = 0;
	unsigned edge_number = 0;
	for (i = 0; i < circle->n - 1; ++i) {
		for (j = i; j < circle->n - 1; ++j) {
			if (circle->points[i].other[j]) {

				double path_len = sqrt(  pow(circle->points[i].x-circle->points[i].other[j]->x,2) +
						pow(circle->points[i].y-circle->points[i].other[j]->y,2) );
				length += path_len;

				if (j == i)
					circumference += path_len;
				if ((i == 0) && (j == circle->n - 2))
					circumference += path_len;

				unsigned u;
				for (u = 0; u < circle->n - 1; ++u) {
					if (circle->points[i].other[j]->other[u] == &circle->points[i]) {
						circle->points[i].other[j]->other[u] = 0;
					}
				}
				edge_number++;
			}
		}
	}

	printf("Number of edges/diagonals: %u\n", edge_number);
	printf("Sum of lengths of edges/diagonals: %.17f\n", length);
	printf("Half of the circumference: %.17f\n", circumference / 2);

	unflatten_fini();
	fclose(in);

	return 0;
}


Running the example with warm caches yields:

------------------------------------------------
$ examples/circular-out
# Unflattening done. Summary:
  Image read time: 0.303173s
  Fixing memory time: 0.112452s
  Total time: 0.415674s
  Total bytes read: 1600240087
Number of edges: 49995000
Sum of lengths of edges/diagonals: 63661976.71272929012775421
Half of the circumference: 3.14159260191227308
------------------------------------------------

Clearing the cache makes things slower as expected:

------------------------------------------------
$ echo 1 > /proc/sys/vm/drop_caches
$ examples/circular-out
# Unflattening done. Summary:
  Image read time: 4.053782s
  Fixing memory time: 0.114766s
  Total time: 4.168599s
  Total bytes read: 1600240087
------------------------------------------------

As showed it the example above unflattening depends mostly on the disk image read time and any further potential optimizations would need be focused on that part.
